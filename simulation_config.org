#+TITLE:  SN@ilWare Simulation Configuration
#+AUTHOR: Xavier Garrido
#+DATE:   2013-02-22
#+OPTIONS: ^:{}
#+STARTUP: entitiespretty

* Introduction

This file contains a SN@ilWare configuration to run SuperNEMO simulations. The
current version is hosted at
[[https://github.com/xgarrido/snemo_simulation_configuration]] under =git= version
control. You can clone this repository by doing

#+BEGIN_SRC shell
  git clone https://github.com/xgarrido/snemo_simulation_configuration snemo_configuration
#+END_SRC

This will create a directory =snemo_configuration= in the working directory
containing all the source files needed to configure and to setup SN@ilWare
programs.

The configuration files are organised using [[http://orgmode.org/worg/org-contrib/babel/index.html][org-babel]] and its ability to execute
source code. It requires then a recent installation of emacs[1] which bundles
=org=. Without entering into too much details regarding =org-babel= abilities,
the basic idea is to give a "literate" way to navigate through the different
sections, each of them representing a configuration file. Moreover, using =org=
folding/unfolding capability, item can be hide and the user can focus on
relevant parts.

To export the different configuration files, you can run =org-babel-tangle=
which will tangle each code block into the given file[2] or use the associated
Makefile. The author recommends to use the Makefile since the tangling process
is asynchronous and thus, does not freeze your emacs (=org-babel-tangle=
"occupies" emacs during its execution).

[1] At the time of writing this document, emacs version is 24.2.
[2] Emacs lisp function can be run using =ALT-x= command and typing the function
name.

* Pipeline general configuration

SN@ilWare implements the concept of data processing pipeline. An event record
object is passed through a chain of data processing modules, each of them being
responsible for a given task. Modules and services are declared in Section
[[Modules]] and Section [[Services]]. For more details on running SuperNEMO simulations
and the concept behind modules/services see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=1889][these mandatory presentations]] given
by F. Mauger.

** Module manager
:PROPERTIES:
:TANGLE: module_manager.conf
:END:
This file is the main and central piece of code for loading all modules/services
needed by =dpp_processing= binary. It provides links to module files and
service files.
*** Logging priority
#+BEGIN_SRC shell
  #@description Module manager logging priority
  logging.priority : string = "warning"

  #@description Embedded module factory debug flag
  factory.debug : boolean = 0

  #@description Embedded module factory 'no preload' flag
  factory.no_preload : boolean = 0
#+END_SRC

*** Service manager configuration
#+BEGIN_SRC shell
  #@description The configuration file of the embedded service manager
  service_manager.configuration : string[1] as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/service_manager.conf"
#+END_SRC

*** Configuration files for modules
#+BEGIN_SRC shell
  #@description The configuration files for modules
  modules.configuration_files : string[10] as path =                     \
      "@SNEMO_SIMULATION_CONFIGURATION@/io_modules.conf"                 \
      "@SNEMO_SIMULATION_CONFIGURATION@/utl_modules.conf"                \
      "@SNEMO_SIMULATION_CONFIGURATION@/simulation_modules.conf"         \
      "@SNEMO_SIMULATION_CONFIGURATION@/event_header_modules.conf"       \
      "@SNEMO_SIMULATION_CONFIGURATION@/calibration_modules.conf"        \
      "@SNEMO_SIMULATION_CONFIGURATION@/tracker_clustering_modules.conf" \
      "@SNEMO_SIMULATION_CONFIGURATION@/tracker_fitting_modules.conf"    \
      "@SNEMO_SIMULATION_CONFIGURATION@/particle_tracking_modules.conf"  \
      "@SNEMO_SIMULATION_CONFIGURATION@/gamma_tracking_modules.conf"     \
      "@SNEMO_SIMULATION_CONFIGURATION@/chain_modules.conf"
#+END_SRC

** Service manager
:PROPERTIES:
:TANGLE: service_manager.conf
:END:
*** Logging priority
#+BEGIN_SRC shell
  #@description Service manager logging priority
  logging.priority : string = "warning"
#+END_SRC
*** Name & description
#+BEGIN_SRC shell
  #@description The name of the service manager
  name : string = "sn_service_manager"

  #@description The description of the service manager
  description : string = "A SuperNEMO service manager"
#+END_SRC
*** List of service files
#+BEGIN_SRC shell
  #@description The list of files that describe services
  services.configuration_files : string[1] as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/services.conf"
#+END_SRC

** DLL loader
*** Code generator                                               :noexport:
:PROPERTIES:
:TANGLE:   no
:RESULTS:  output
:END:
This skeleton code ease the declaration of dll loader since it
receives a table list and builds the corresponding =dlls.conf= file.

#+NAME: dll_loader
#+HEADERS: :var name="" :var filename="" :shebang "#!/bin/bash"
#+BEGIN_SRC shell
  echo '#@description A sample list of setups'
  echo '#@key_label   "name"'
  echo '#@meta_label  "filename"'
  arr_name=(${name})
  arr_filename=($filename)
  for ((i=0; i < ${#arr_name[@]}; i++))
  do
      dll=${arr_name[$i]}
      dllpath=${arr_filename[$i]}
      if [ "$dllpath" != "none" ]; then
          echo '[name="'$dll'" filename="'$dllpath'"]'
      else
          echo '[name="'$dll'" filename=""]'
      fi
      echo '#config The '$dll' library'
      echo 'autoload : boolean = 1'
      echo
  done
#+END_SRC
*** Libraries
:PROPERTIES:
:TANGLE: dlls.conf
:END:
This part set the different libraries to be loaded at runtime. This is needed
since event data models or algorithms may be defined in other libraries than the
=dpp= and inherited libraries. The following table sets a full (and exhaustive)
list of needed libraries

#+CAPTION: *Libraries to be used by modules.*
#+TBLNAME: dll_libraries
|-----------------------+------------------------------------------------------------------------------------------------|
| Bayeux_mctools_geant4 | $SNAILWARE_PRO_DIR/bayeux/install/lib64/libBayeux_mctools_geant4.so                            |
| Falaise               | $SNAILWARE_PRO_DIR/falaise/install/lib64/libFalaise.so                                         |
| Falaise_MTC           | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libFalaise_MockTrackerClusterizer.so  |
| Falaise_CAT           | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libFalaise_CAT.so                     |
| TrackFit              | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libTrackFit.so                        |
| Falaise_TrackFit      | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libFalaise_TrackFit.so                |
| Falaise_CPT           | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libFalaise_ChargedParticleTracking.so |
| GammaTracking         | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libGammaTracking.so                   |
| Falaise_GammaTracking | $SNAILWARE_PRO_DIR/falaise/install/lib64/Falaise/modules/libFalaise_GammaTracking.so           |
|-----------------------+------------------------------------------------------------------------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<dll_loader(dll_libraries[*,0], dll_libraries[*,1])>>
#+END_SRC
* Modules

A data processing module is an object that performs some specific action (apply
an algorithm) on event records (see [[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Dataprocessingmodules][SN@ilWare FAQ]] for more details). It inherits
the =dpp::base_module= mother/interface class. A module class implements a few
mandatory methods :

- constructor
- destructor
- =initialize=
- =reset=
- =process=

The next items hold the configuration for several modules used in SN@ilWare
pipeline processing.

** Skeleton codes                                                 :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
This section provides some options to create and declare general modules such as
I/O modules (see Section [[I/O modules]]) or/and removing data bank. Since these
tasks are quite generic and depends to few parameters, the following code blocks
provides easy interface to such modules. The section [[I/O modules]] provides
example on how to use skeleton codes.

*** Skeleton code for output module
This skeleton code allows to define output module given the name of the
module. It also defines the output directory where to store each output steps.

#+NAME: output_module
#+HEADERS: :var mname="" :var logging="warning" :var ofilename=""
#+BEGIN_SRC shell
  IO_OUTPUT_DIRECTORY="/tmp/\${USER}/snemo.d"
  if [ ! -d ${IO_OUTPUT_DIRECTORY} ]; then
      mkdir -p $(eval "echo ${IO_OUTPUT_DIRECTORY}")
  fi
  echo '[name="'$mname'" type="dpp::output_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description Output file mode'
  echo 'files.mode : string = "single"'
  echo
  echo '#@description Path to output data file'
  if [ -z ${ofilename} ]; then
      echo 'files.single.filename : string as path = "'$IO_OUTPUT_DIRECTORY/$mname'.brio"'
  else
      echo 'files.single.filename : string as path = "'$ofilename'"'
  fi
  echo
  echo '#@description The label of the Context service'
  echo 'Ctx_label : string  = "Ctx"'
#+END_SRC

*** Skeleton code for removing data bank

#+NAME: remove_module
#+HEADERS: :var mname="" :var mode="remove_banks" :var label="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$mname'" type="dpp::utils_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description The processor mode'
  echo 'mode : string = "'$mode'"'
  echo
  echo '#@description The label to be removed'
  echo 'mode.'$mode'.labels : string[1] = "'$label'"'
#+END_SRC

*** Skeleton code for chain module
This skeleton code ease the declaration of =chain_module= processor since it
receives a table list and builds the =chain_module= declaration given its name.

#+NAME: chain_module
#+HEADERS: :var mname="" :var nmodule=0 :var list="module1 module2 module3" :var logging="warning"
#+BEGIN_SRC shell
  vlist=(${=list})
  echo '[name="'$mname'" type="dpp::chain_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description The list of processing modules to be applied (in this order)'
  echo 'modules : string['$nmodule'] = \'
  for i in $vlist
  do
      echo -n \"$i\"
      if [ $i != $vlist[-1] ]; then echo ' \';fi
  done
#+END_SRC

*** Skeleton code for =if= module
This skeleton code is a template to declare =if_module= processor.

#+NAME: if_module
#+HEADERS: :var mname="" :var cut="" :var then="" :var else="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$mname'" type="dpp::if_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description The label/name of the cut service'
  echo 'cut_service.label : string = "Cuts"'
  echo
  echo '#@description The name of the condition cut'
  echo 'condition_cut : string = "'$cut'"'
  echo
  echo '#@description The name of the module to be processed when condition is checked'
  echo 'then_module : string = "'$then'"'
  echo
  echo '#@description The name of the module to be processed when condition is NOT checked'
  echo 'else_module : string = "'$else'"'
#+END_SRC

** Mandatory preamble                                             :noexport:

This piece of code is not tangled by =org= but inserted into all module
preamble. This is mandatory in order to load properly and statically the
modules. Every module declared in this file must include this code block by
putting =<<module_preamble>>= in their module header declaration (before
anything else). The module code block should then use the =:noweb yes= option to
expand the =module_preamble= code.

#+NAME: module_preamble
#+BEGIN_SRC shell :results none :tangle no
  #@description A sample list of setups
  #@key_label   "name"
  #@meta_label  "type"
#+END_SRC

** I/O modules
:PROPERTIES:
:TANGLE: io_modules.conf
:END:

This section defines some I/O output modules to store data record. By default,
all I/O files are saved in =/tmp/${USER}/snemo.d= directory.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Simulation output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_simulated")>>
#+END_SRC

*** Calibration output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_calibrated")>>
#+END_SRC

*** Tracker clustering output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_tracker_clustering")>>
#+END_SRC

*** Tracker trajectory output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_tracker_trajectory")>>
#+END_SRC

*** Particle track output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_particle_track")>>
#+END_SRC

*** Analysis output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_analysed")>>
#+END_SRC

*** Selection output

- Simulation cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_simulated_selected")>>
    <<output_module("io_output_simulated_non_selected")>>
  #+END_SRC

- Calibration cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_calibrated_selected")>>
    <<output_module("io_output_calibrated_non_selected")>>
  #+END_SRC

- Tracking cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_tracker_clustering_selected")>>
    <<output_module("io_output_tracker_clustering_non_selected")>>
  #+END_SRC

- Fitting cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_tracker_trajectory_selected")>>
    <<output_module("io_output_tracker_trajectory_non_selected")>>
  #+END_SRC

- Particle track cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_particle_track_selected")>>
    <<output_module("io_output_particle_track_non_selected")>>
  #+END_SRC

** Utility modules
:PROPERTIES:
:TANGLE: utl_modules.conf
:END:

Here we define some common and useful tasks such as removing data/MC hits.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Remove event header
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_header", label="EH", logging="warning")>>
#+END_SRC

*** Remove simulated data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_simulated_data", label="SD", logging="warning")>>
#+END_SRC
*** Remove calibrated data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_calibrated_data", label="CD", logging="warning")>>
#+END_SRC

*** Remove tracker clustering data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_tracker_clustering_data", label="TCD", logging="warning")>>
#+END_SRC
*** Remove tracker trajectory data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_tracker_trajectory_data", label="TTD", logging="warning")>>
#+END_SRC
*** Remove particle track data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_particle_track_data", label="PTD", logging="warning")>>
#+END_SRC
*** Dump module
#+BEGIN_SRC shell
  [name="dump" type="dpp::dump_module"]

  #@description Output stream
  output : string = "clog"
#+END_SRC
** Simulation module
:PROPERTIES:
:TANGLE: simulation_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** G4 simulation
A processor that populate the event record =simulated data= bank with Geant4
output (see [[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Monte-Carloproduction][SN@ilWare FAQ]]).
#+BEGIN_SRC shell
  [name="simulation" type="mctools::g4::simulation_module"]
#+END_SRC

**** Logging flag
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = "warning"

  #@description The simulation manager logging priority
  manager.logging.priority : string = "warning"
#+END_SRC
**** Bank & service labels
#+BEGIN_SRC shell
  #@description The Geometry Service label
  Geo_label : string = "Geo"

  #@description The 'Simulated data' bank label in the event record
  SD_label  : string = "SD"

  #@description Flag to allow cleaning of some former simulated data bank if any (default: 0)
  erase_former_SD_bank : boolean = 0
#+END_SRC
**** Seed values
#+BEGIN_SRC shell
  #@description The simulation manager PRNG seed
  manager.seed                  : integer = 2

  #@description The vertex generator PRNG seed
  manager.vertex_generator_seed : integer = 4

  #@description The event generator PRNG seed
  manager.event_generator_seed  : integer = 5

  #@description The SHPF PRNG seed
  manager.shpf_seed             : integer = 6

  #@description The saving of PRNG seeds
  manager.output_prng_seeds_file  : string as path = "/tmp/${USER}/snemo.d/prng_seeds.save"

  #@description The saving of PRNG states
  manager.output_prng_states_file : string as path = "/tmp/${USER}/snemo.d/prng_states.save"

  #@description The modulo for PRNG states backup
  manager.prng_states_save_modulo : integer = 10
#+END_SRC
**** Vertex generator
#+BEGIN_SRC shell
  #@description The vertex generator PRNG label
  manager.vertex_generator_name : string  = "source_strips_bulk"
  #manager.vertex_generator_name : string  = "pmt_glass_bulk"
#+END_SRC

**** Event generator
#+BEGIN_SRC shell
  #@description The event generator PRNG label
  #manager.event_generator_name  : string  = "Se82.0nubb"
  #manager.event_generator_name  : string  = "Bi214_Po214"
  manager.event_generator_name  : string  = "Tl208"
  #manager.event_generator_name  : string = "multi_particles"
#+END_SRC
**** G4 manager
The full =geant4= configuration can be found in the [[file:./sng4_manager.org][sng4_manager]] file.
#+BEGIN_SRC shell
  #@description The simulation manager configuration file
  manager.configuration_filename : string as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/sng4_manager.conf"
#+END_SRC

** Event header module
:PROPERTIES:
:TANGLE: event_header_modules.conf
:END:

After Geant4 simulation, no event header is added and available in the event
record. This module adds some information related either to real data (run
number) or simulated data like =genbb= weight in case the total energy of primary
particles has been restricted.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** General informations
#+BEGIN_SRC shell
  [name="add_header" type="snemo::processing::event_header_utils_module"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The processor mode
  mode : string = "add_header"

  #@description The label of the 'Event Header' bank
  add_header.bank_label : string = "EH"

  #@description The run number
  add_header.run_number : integer = 0

  #@description The number of the first event number to be set
  add_header.event_number : integer = 0

  #@description The event weight given by GENBB and used for 'energy_range' mode
  add_header.use_genbb_weight : boolean = 1

  #@description The event label from GENBB settings
  add_header.use_genbb_label  : boolean = 1
#+END_SRC

Among the options offered by =event_header_utils_module=, there is a possibility
to give an external file (following =datatools::properties= writing conventions)
where additionnal informations can be added. Typical use case is the definition
of some properties/descriptions of simulation runs (see below).

The =external_properties_prefix= allows to filter which properties should be
stored. If no =external_properties_prefix= field is defined then all the
properties are used and serialized.

#+BEGIN_SRC shell
  #@description The external properties files to be exported in event_header properties
  add_header.external_properties_path : string as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/snsimulation_header.conf"

  #@description The external properties prefix to export only properties starting with this prefix
  add_header.external_properties_prefix : string = "analysis"
#+END_SRC

*** Analysis informations
:PROPERTIES:
:TANGLE: snsimulation_header.conf
:END:
**** Getting branch status                                      :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
The following code block allows to "tag" the current version /i.e./ getting the
=git= branch name, commit chunk

#+NAME: vc-status
#+BEGIN_SRC shell
  if [ -d .git ]; then
      log+="git "$(git rev-parse --abbrev-ref HEAD)" branch - "
      log+=$(LC_MESSAGES=en git --no-pager log -1 HEAD --date=short --pretty=format:"commit %h - %ad")
      echo -n $log
  fi
#+END_SRC

**** Getting component version                                  :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
The following code block retrieves the version number of a given component
#+NAME: code-version
#+HEADERS: :var name="" :var binary=1
#+BEGIN_SRC shell :noweb yes
  if [ "$name" != "" ]; then
      if [ $binary -eq 1 ]; then
          echo -n "$($name-config --version)"
      else
          cd $($name-config --prefix)/..
          status=$(LC_MESSAGES=en git svn info)
          rev=$(echo -e $status | sed -n 's/.*Revision: *\([^ ]*\).*/\1/p')
          date=$(echo -e $status | sed -n 's/.*Last Changed Date: *\([^ ]*\).*/\1/p')
          log="svn revision ${rev} - ${date}"
          echo -n $log
      fi
  fi
#+END_SRC
**** Store the current =git= version of the configuration
#+BEGIN_SRC shell :noweb yes
  #@description The version control status
  analysis.vc_status : string = "<<vc-status()>>"
#+END_SRC

**** Set analysis description
#+BEGIN_SRC shell
  #@description The analysis description
  analysis.description : string = "Sensitivity studies for SuperNEMO demonstrator"
#+END_SRC

**** Set the total number of event simulated
#+BEGIN_SRC shell
  #@description The total number of event simulated
  analysis.total_number_of_event : real = 1e5
#+END_SRC

**** Set the geometrical origin of the vertex
#+BEGIN_SRC shell
  #@description Origin of the vertices
  analysis.vertex_origin : string = "foil"
#+END_SRC

**** Store the job id
When simulations are done @ Lyon and send to the Grid Engine, every process get
a unique job-ID. We store it within the event header in order to get back to the
simulation setup if needed.
#+BEGIN_SRC shell
  #@description The job-ID of the process
  analysis.jobid : integer = 0
#+END_SRC
*** Update informations
#+BEGIN_SRC shell
  [name="update_header" type="snemo::processing::event_header_utils_module"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The processor mode
  mode : string = "add_header"

  #@description The label of the 'Event Header' bank
  add_header.bank_label : string = "EH"

  #@description Update flag
  add_header.update : boolean = 1

  #@description The external properties files to be exported in event_header properties
  add_header.external_properties_path : string as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/snsimulation_header.conf"

  #@description The external properties prefix to export only properties starting with this prefix
  add_header.external_properties_prefix : string = "analysis"
#+END_SRC

** Calibration modules
:PROPERTIES:
:TANGLE: calibration_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Tracker simulation to calibration data

This module converts simulated data into calibrated data for SuperNEMO
tracker. It is a mock digitization/calibration data module of Monte-Carlo
hits. It applies some anode/cathode efficiencies as well as calibration and
smearing curves to translate times into longitudinal and transerve
positions. Main reference documents for this module can be find in DocDb [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=786][#786]]
and [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=843][#843]].

#+BEGIN_SRC shell
  [name="tracker_s2c" type="snemo::processing::mock_tracker_s2c_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = "warning"
#+END_SRC

**** Data bank labels and hit category
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Simulated Data' bank
  SD_label : string  = "SD"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The category of hits to be processed as Geiger hits
  hit_category  : string  = "gg"
#+END_SRC

**** Random generator
#+BEGIN_SRC shell
  #@description Pseudo-random numbers generator setup
  random.id   : string  = "mt19937"
  random.seed : integer = 12345
#+END_SRC

**** Geiger cells dimensions
#+BEGIN_SRC shell
  #@description Drift cell effective/active diameter
  cell_diameter : real as length = 44.0 mm

  #@description Drift cell effective/active length
  cell_length : real as length = 2900.0 mm
#+END_SRC

**** Anode/cathode efficiencies
#+BEGIN_SRC shell
  #@description anode efficiency
  base_anode_efficiency   : real = 1.0

  #@description cathode efficiency
  base_cathode_efficiency : real = 1.0
#+END_SRC
**** Plasma longitudinal speed
#+BEGIN_SRC shell
  #@description plasma longitudinal speed
  plasma_longitudinal_speed : real as velocity = 5.0 cm/us
#+END_SRC

**** Longitudinal & transerve reconstruction parameters
#+BEGIN_SRC shell
  #@description Error on reconstructed longitudinal position (from a plot by Irina)
  sigma_z : real as length = 1.0 cm # (to be confirmed)

  #@description Error on reconstructed longitudinal position when one cathode signal is missing
  sigma_z_missing_cathode  : real as length = 5.0 cm # (to be confirmed)

  #@description Error on reconstructed horizontal position (parameters of a fit of data by Irina)
  sigma_r_a  : real as length = 0.425 mm
  sigma_r_b  : real = 0.0083
  sigma_r_r0 : real as length = 12.25 mm
#+END_SRC

**** Delayed drift time threshold
#+BEGIN_SRC shell
  # #@description Time threshold to tag Geiger cells as delayed
  # delayed_drift_time_threshold : real as time = 10 us
#+END_SRC
*** Calorimeter simulation to calibration data

This module converts Monte-Carlo hits into calorimeter hits. Like the previous
[[#tracker_s2c][section]], it is a mock digitization/calibration of simulation hits. It basicaly
aggregates several energy deposits, calculates the total energy deposited and
the time of the first energy deposit and finally, it smears the energy and time
by some experimental energy/time resolution. There is also a special treatments
for the quenching of alpha particles.

#+BEGIN_SRC shell
  [name="calorimeter_s2c" type="snemo::processing::mock_calorimeter_s2c_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = "warning"
#+END_SRC

**** Data bank labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Simulated Data' bank
  SD_label : string  = "SD"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"
#+END_SRC
**** Random generator
#+BEGIN_SRC shell
  #@description Pseudo-random numbers generator setup
  random.id   : string  = "mt19937"
  random.seed : integer = 12345
#+END_SRC

**** Activate \alpha quenching
#+BEGIN_SRC shell
  #@description Alpha quenching boolean
  alpha_quenching : boolean = 1
#+END_SRC
**** Calorimeter regimes
***** Hit categories
#+BEGIN_SRC shell
  #@description The categories of hits to be processed as calorimeter hits
  hit_categories  : string[3]  = "calo" "xcalo" "gveto"
#+END_SRC
***** \alpha quenching parameters
We do not use these parameters
#+BEGIN_SRC shell
  #@description Alpha quenching parameters
  calo.alpha_quenching_parameters  : real[3] = 77.4 0.639 2.34
  xcalo.alpha_quenching_parameters : real[3] = 77.4 0.639 2.34
  gveto.alpha_quenching_parameters : real[3] = 77.4 0.639 2.34
#+END_SRC

***** Scintillator relaxation time for time resolution
#+BEGIN_SRC shell
  #@description Time resolution parameters
  calo.scintillator_relaxation_time  : real as time = 6.0 ns
  xcalo.scintillator_relaxation_time : real as time = 6.0 ns
  gveto.scintillator_relaxation_time : real as time = 6.0 ns
#+END_SRC

***** Energy resolutions
#+BEGIN_SRC shell
  #@description Optical lines resolutions (FWHM @ 1 MeV)
  calo.energy.resolution  : real = 0.08
  xcalo.energy.resolution : real = 0.12
  gveto.energy.resolution : real = 0.15
#+END_SRC

***** Energy thresholds
#+BEGIN_SRC shell
  #@description Optical lines trigger thresholds
  calo.energy.high_threshold  : real as energy = 150 keV
  xcalo.energy.high_threshold : real as energy = 150 keV
  gveto.energy.high_threshold : real as energy = 150 keV

  calo.energy.low_threshold   : real as energy = 50 keV
  xcalo.energy.low_threshold  : real as energy = 50 keV
  gveto.energy.low_threshold  : real as energy = 50 keV
#+END_SRC

** Tracker clustering modules
:PROPERTIES:
:TANGLE: tracker_clustering_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Clustering algorithms

This section holds different modules all related to tracker clustering.

**** Mock tracker clustering

This algorithm is too much simple but it can serve as a comparison point with
respect to more elaborated algorithms in terms of time processing. It basically
associates geiger cells but considering succesive neighbors. It does not use the
longitudinal information and then can badly aggregates track belonging to two
different particles.

#+BEGIN_SRC shell
  [name="mock_tracker_clustering" type="snemo::reconstruction::mock_tracker_clustering_module"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Tracker Clusterizer logging priority
  TC.logging.priority : string = "warning"

  #@description Maximum layer distance between two neighbour hits
  MTC.max_layer_distance : integer = 2

  #@description Maximum row distance between two neighbour hits
  MTC.max_row_distance   : integer = 2

  #@description Maximum row+layer distance between two neighbour hits
  MTC.max_sum_distance   : integer = 0
#+END_SRC

# We also add an option to not split the tracker chamber when pre clustering is
# done by =TrackerPreClusterizer=. This option is set to true by default but here
# with the =mock_tracker_clustering_module= it does not make sense since cells are
# already ordered by time. So to avoid confusion (especially to avoid double
# tracker clustering solution), we do not ak pre-clustering to split the chamber.

# #+BEGIN_SRC shell
#   #@description Tracker pre clusterizer splitting chamber option
#   TPC.split_chamber : boolean = 0
# #+END_SRC

**** Cellular Automaton Tracker

This algorithm provides tons of parameters and is based in F. Nova work. A
somewhat complete overview of CAT main features can be seen in DocDb [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2120][#2120]].

#+BEGIN_SRC shell
  [name="cat_tracker_clustering" type="snemo::reconstruction::cat_tracker_clustering_module"]

  #@description Logging support
  logging.priority : string = "warning"

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = 1

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = 0

  # #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  # TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Pre-clusterizer processing separately both sides of the tracking chamber
  TPC.split_chamber : boolean = 0

  # #@description Force the CAT algorithm to consider a 25 gauss magnetic field (temporary trick)
  # CAT.magnetic_field : real = 25 gauss
#+END_SRC

**** SULTAN tracker

Federico Nova recently implements a new way to cluster Geiger cells by
translating their intrinsic parameters namely cell position, drift radius and
azimuthal position in Legendre phase space. The idea was originally suggested by
Yorck Ramachers (see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2556][DocDB 2256]]) and Federico added the ability to fit helix
(see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2977][DocDB 2977]] as well as the [[http://www.sciencedirect.com/science/article/pii/S0168900208005780][original paper]]).

#+BEGIN_SRC shell
  [name="sultan_tracker_clustering" type="snemo::reconstruction::sultan_tracker_clustering_module"]

  #@description Logging support
  logging.priority : string = "warning"

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = 1

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = 0

  # #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  # TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Activation of the clustering of delayed hits
  TPC.split_chamber : boolean = 0

  # #@description To be described
  # SULTAN.clusterizer_level  : string  = "normal"

  # #@description To be described
  # SULTAN.sequentiator_level : string  = "normal"

  # #@description Use calorimeter hits information to help clustering
  # SULTAN.process_calo_hits : boolean = 1

  # #@description Clusterize with helix model
  # SULTAN.clusterize_with_helix_model : boolean = 1

  # #@description Force the SULTAN algorithm to consider a 25 gauss magnetic field (temporary trick)
  # SULTAN.magnetic_field : real = 25 gauss

  # #@description To be described
  # SULTAN.max_time : real = 5000 ms

  # #@description Use online event display (devel only)
  # SULTAN.print_event_display : boolean = 0

  # #@description To be described
  # SULTAN.Emin : real  = 120 keV

  # #@description To be described
  # SULTAN.Emax : real  = 3.3 MeV

  # #@description To be described
  # SULTAN.nsigma_r : real  = 3.0

  # #@description To be described
  # SULTAN.nsigma_z : real  = 4.0

  # #@description To be described
  # SULTAN.nofflayers : integer = 1

  # #@description To be described
  # SULTAN.first_event : integer = -1

  # #@description To be described
  # SULTAN.min_ncells_in_cluster : integer = 7

  # #@description To be described
  # SULTAN.ncells_between_triplet_min : integer = 1

  # #@description To be described
  # SULTAN.ncells_between_triplet_range : integer = 3

  # #@description To be described
  # SULTAN.nsigmas : real  = 1.0

  # #@description To be described
  # SULTAN.sigma_z_factor : real  = 1.0

  # #@description Clusterize with endpoints
  # SULTAN.use_endpoints : boolean = 1

  # #@description Clusterize with Legendre transform
  # SULTAN.use_legendre : boolean = 0

  # #@description Use clocks to time different parts of the software
  # SULTAN.use_clocks : boolean = 0
#+END_SRC

**** Tracker Cluster Path                                     :notworking:
This algorithm has been developped by Warwick group since June 2012 and mainly
by K. Bhardwaj.

#+BEGIN_SRC shell
  [name="tcp_tracker_clustering" type="snemo::reconstruction::processing::tracker_clustering_module"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description The ID of the tracker hits clustering algorithm
  algorithm : string  = "TCP"

  #@description The module number
  module_number : integer = 0

  #@description The geometry category of the Geiger drift volume
  gg_cell_geom_category : string = "drift_cell_core"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = 1

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = 1

  #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Activation of the clustering of delayed hits
  TPC.split_chamber : boolean = 1

  #@description TCP param
  TCP.gamma : integer = 3

  #@description TCP param
  TCP.lambda : real = 0.1

  #@description TCP param
  TCP.join_threshold : real = 0.70

  #@description TCP param
  TCP.opt_threshold : real = 0.00001

  #@description TCP param
  TCP.lambda_factor : real = 1.05

  #@description TCP param
  TCP.smooth : integer = 0

  #@description TCP param
  TCP.max_iterations : integer = 1000

  #@description TCP param
  TCP.line_search_freq : integer = 2

  #@description TCP param
  TCP.line_search_points : integer = 10

  #@description TCP param
  TCP.check_splits : integer = 1

  #@description TCP param
  TCP.target_cluster : integer = 0

  #@description TCP param
  TCP.max_number_of_clusters_allowed : integer = 3

  #@description TCP param
  TCP.verbose : integer = 0

  #@description TCP param
  TCP.refinement_no : integer = 5

  #@description TCP param
  TCP.line_tolerance : real = 0.39

  #@description TCP param
  TCP.point_tolerance : real = 100
#+END_SRC

** Tracker fitting module
:PROPERTIES:
:TANGLE: tracker_fitting_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Fitting algorithm
As the time of writing this document, there is only one algorithm well
integrated into SN@ilWare pipeline. It is based on [[https://nemo.lpc-caen.in2p3.fr/wiki/trackfit][trackfit]] originally
developped and tested on NEMO3 data. It is quite an agnostic algorithm in the
sense that it only asked for cells position and drift radius. Fitting process is
done by GSL minimizer to find the global solution given the model: either helix
or line models.

#+BEGIN_SRC shell
  [name="trackfit_tracker_fitting" type="snemo::reconstruction::trackfit_tracker_fitting_module"]
#+END_SRC

**** General logging
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = "warning"
#+END_SRC

**** Data bank & services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description The label of the 'Tracker Trajectory Data' bank
  TTD_label : string  = "TTD"
#+END_SRC

**** General options
#+BEGIN_SRC shell
  #@description The maximum number of fits to be saved (0 means all will be kept)
  maximum_number_of_fits : integer = 0
#+END_SRC

**** Trackfit algorithm
#+BEGIN_SRC shell
  #@description The ID of the tracker fitting algorithm
  algorithm : string  = "trackfit"
#+END_SRC

***** Drift time calibration
For time delayed cluster like alpha particle track, a /a posteriori/ drift time
calibration has to be done to shift the time origin and then calculates the new
cell radius. The =drift_time_calibration= can be anything if it respects some
object interface rules defines in =trackfit::i_drift_time_calibration=
class. Here we use the same model as in Section [[Tracker simulation to calibration data]].
#+BEGIN_SRC shell
  #@description Use drift time (re)calibration
  drift_time_calibration_label : string = "snemo"
#+END_SRC

***** Fit models
#+BEGIN_SRC shell
  #@description Fit models
  fitting_models : string[2] = "line" "helix"
#+END_SRC
***** Line fit parameters
****** Guess parameters
#+BEGIN_SRC shell
  #@description Activate logging messages for line guess driver
  line.guess.logging.priority  : string = "error"

  #@description Use max radius (cell size) to construct initial guess point (1) or use the effective drift Geiger distance of the hit (0)
  line.guess.use_max_radius    : boolean = 0

  #@description Apply a factor (>0) to the max radius (devel mode)
  line.guess.max_radius_factor : real = 1.0

  #@description Use guess trust (1) or keep all of the guess fits (0) and select later
  line.guess.use_guess_trust   : boolean = 0

  #@description Mode for trusting a fit guess ("counter", "barycenter")
  line.guess.guess_trust_mode  : string = "counter"

  #@description Fit the delayed geiger cluster
  line.guess.fit_delay_cluster : boolean = 1
#+END_SRC

****** Fit parameters
#+BEGIN_SRC shell
  #@description 'Line' fit only guess ("BB", "BT", "TB", "TT")
  #line.only_guess : string[1] = "TT"

  #@description Store only the N solutions with best line fit
  #line.store_number_of_solutions : integer = 2

  #@description Print the status of the fit stepper at each step (devel only)
  line.fit.step_print_status : boolean = 0

  #@description Plot the 2D view of the fitted data at each step (devel only)
  line.fit.step_draw         : boolean = 0

  #@description Track fit adds start time as an additionnal parameter to the fit (needs a calibration driver)
  line.fit.fit_start_time    : boolean = 0

  #@description Track fit recomputes the drift distance from drift time (needs a calibration driver)
  line.fit.using_drift_time  : boolean = 0

  #@description Allow a fitted track to begin not tangential to the first hit
  line.fit.using_first       : boolean = 0

  #@description Allow a fitted track to end not tangential to the last hit
  line.fit.using_last        : boolean = 0
#+END_SRC
***** Helix fit parameters
****** Guess parameters
#+BEGIN_SRC shell
  #@description Activate logging messages for helix guess driver
  trackfit.helix.guess.logging.priority  : string = "error"

  #@description Use max radius (cell size) to construct initial guess point (1) or use the effective drift Geiger distance of the hit (0)
  trackfit.helix.guess.use_max_radius    : boolean = 0

  #@description Apply a factor (>0) to the max radius (devel mode)
  trackfit.helix.guess.max_radius_factor : real = 1.0

  #@description Use guess trust (1) or keep all of the guess fits (0) and select later
  trackfit.helix.guess.use_guess_trust   : boolean = 0

  #@description Mode for trusting a fit guess ("counter", "barycenter")
  trackfit.helix.guess.guess_trust_mode  : string = "counter"

  #@description Fit the delayed geiger cluster (by default, false since this mode is devoted to line fit)
  trackfit.helix.guess.fit_delay_cluster : boolean = 0
#+END_SRC
****** Fit parameters
#+BEGIN_SRC shell
  #@description 'Helix' fit only guess ("BBB", "BBT", "BTB", "BTT", "TBB", "TBT", "TTB", "TTT")
  #trackfit.helix.only_guess : string[1] = "TTT"

  #@description Store only the N solutions with best helix fit
  #trackfit.helix.store_number_of_solutions : integer = 2

  #@description Print the status of the fit stepper at each step (devel only)
  trackfit.helix.fit.step_print_status : boolean = 0

  #@description Plot the 2D view of the fitted data at each step (devel only)
  trackfit.helix.fit.step_draw         : boolean = 0

  #@description Track fit recomputes the drift distance from drift time (needs a calibration driver)
  trackfit.helix.fit.using_drift_time  : boolean = 0

  #@description Allow a fitted track to begin not tangential to the first hit
  trackfit.helix.fit.using_first       : boolean = 0

  #@description Allow a fitted track to end not tangential to the last hit
  trackfit.helix.fit.using_last        : boolean = 0
#+END_SRC

** Particle tracking module
:PROPERTIES:
:TANGLE: particle_tracking_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Charged particle tracking
Given results of the two previous steps /i.e./ clustering and fitting, the
trajectories must be interpreted within SuperNEMO detector geometry. The
particle tracking translates trajectory into particle tracks and then determines
the track charge (assuming particle comes from the source foil), it extrapolates
track intersection with calorimeter walls and finally it associates particle
track with calorimeter blocks.

#+BEGIN_SRC shell
  [name="charged_particle_tracking" type="snemo::reconstruction::charged_particle_tracking_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = "warning"
#+END_SRC
**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Trajectory Data' bank
  TTD_label : string  = "TTD"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string  = "PTD"
#+END_SRC
**** Drivers
The particle track reconstruction is done within several drivers, each one
having a dedicated tasks such as to compute track charge or to associate
particle track with calorimeter block. The way to perform these "actions" is
then decorelated with the pipeline execution. Other algorithms can be
implemented but the particle tracking module will stay unchanged.
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  drivers : string[3] = "VED" "CCD" "CAD"
#+END_SRC

***** Vertex Extrapolation Driver
#+BEGIN_SRC shell
  #@description Vertex Extrapolation Driver logging priority
  VED.logging.priority : string = "warning"

  #@description Use linear extrapolation (not implemented yet)
  VED.use_linear_extrapolation : boolean = 0
#+END_SRC

***** Charge Computation Driver
#+BEGIN_SRC shell
  #@description Charge Computation Driver logging priority
  CCD.logging.priority : string = "warning"

  #@description Charge sign convention
  CCD.charge_from_source : boolean = 1
#+END_SRC

***** Calorimeter Association Driver
#+BEGIN_SRC shell
  #@description Calorimeter Association Driver logging priority
  CAD.logging.priority : string = "warning"

  #@description Maximum matching distance for track/calo association
  CAD.matching_tolerance : real as length = 100 mm

  #@description Use a simpler approach by looking for gieger cells in front of calo (not implemented yet)
  CAD.use_last_geiger_cell : boolean = 0
#+END_SRC
** \gamma tracking module
:PROPERTIES:
:TANGLE: gamma_tracking_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** \gamma tracking

#+BEGIN_SRC shell
  [name="gamma_tracking" type="snemo::reconstruction::gamma_tracking_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = "warning"
#+END_SRC
**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string  = "PTD"
#+END_SRC
**** Driver
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  driver : string = "GT"
#+END_SRC
**** \gamma tracking setup
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  gt.logging.priority : string = "warning"
#+END_SRC
***** Minimal probability
The following value sets the minimal TOF probability to accept a pair of
calorimeters.
#+BEGIN_SRC shell
  #@description Minimal TOF probability
  gt.minimal_probability : real = 1e-5
#+END_SRC
***** Use probability rather than gamma number
The =absolute= variable forces the gamma tracking algorithm to choose the
calorimeter assocation in the base of the best probability and not in relation
with the number of gammas.
#+BEGIN_SRC shell
  #@description Prefer probability rather than size of gamma tracked
  gt.use_absolute : boolean = 0
#+END_SRC

***** Maximum size of the gamma tracked
#+BEGIN_SRC shell
  #@description Maximum size of a gamma tracked
  gt.maximal_gamma_size : integer = 0
#+END_SRC
** Chain modules
:PROPERTIES:
:TANGLE: chain_modules.conf
:END:
This section holds most of the chain module to set "to music" the different
modules and tasks. It also contains the different paths given the selection
requirements. One important point is that module order really matters since a
module, especially =chain_module=, needs to know the declaration of all the
modules it contains.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Analysis chain
#+CAPTION: *Modules used by the analysis process.*
#+TBLNAME: analysis_chain
|-----------------------------------|
| io_output_particle_track_selected |
| remove_simulated_data             |
| remove_calibrated_data            |
| remove_tracker_clustering_data    |
| remove_tracker_trajectory_data    |
| io_output_analysed                |
|-----------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("analysis_chain", 6, analysis_chain)>>
#+END_SRC

*** Process after selecting particle track
#+BEGIN_SRC shell :noweb yes
   <<if_module("process_with_particle_track_cuts", cut="particle_track_cut", then="analysis_chain", else="io_output_particle_track_non_selected")>>
#+END_SRC

*** Particle tracking chain
#+CAPTION: *Modules used by the particle tracking process.*
#+TBLNAME: particle_tracking_chain
|----------------------------------|
| remove_particle_track_data       |
| charged_particle_tracking        |
| gamma_tracking                   |
| io_output_particle_track         |
| process_with_particle_track_cuts |
|----------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("particle_tracking_chain", 5, particle_tracking_chain)>>
#+END_SRC

*** Process after fitting selection
#+BEGIN_SRC shell :noweb yes
   <<if_module("process_with_fitting_cuts", cut="tracker_trajectory_cut", then="particle_tracking_chain", else="io_output_tracker_trajectory_non_selected")>>
#+END_SRC

*** Fitting chain
#+CAPTION: *Modules used by the fitting process.*
#+TBLNAME: fitting_chain
|--------------------------------|
| remove_tracker_trajectory_data |
| trackfit_tracker_fitting       |
| io_output_tracker_trajectory   |
| process_with_fitting_cuts      |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("fitting_chain", 4, fitting_chain)>>
#+END_SRC

*** Process after clustering selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_clustering_cuts", cut="tracker_clustering_cut", then="fitting_chain", else="io_output_tracker_clustering_non_selected")>>
#+END_SRC

*** Clustering chain
#+CAPTION: *Modules used by the clustering process.*
#+TBLNAME: clustering_chain
|--------------------------------|
| remove_tracker_clustering_data |
| cat_tracker_clustering         |
| io_output_tracker_clustering   |
| process_with_clustering_cuts   |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("clustering_chain", 4, clustering_chain)>>
#+END_SRC

*** Process after calibration selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_calibrated_cuts", cut="calibrated_cut", then="clustering_chain", else="io_output_calibrated_non_selected")>>
#+END_SRC

*** Calibration chain
#+CAPTION: *Modules used by the calibration process.*
#+TBLNAME: calibration_chain
|------------------------------|
| add_header                   |
| tracker_s2c                  |
| calorimeter_s2c              |
| io_output_calibrated         |
| process_with_calibrated_cuts |
|------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("calibration_chain", 5, calibration_chain)>>
#+END_SRC

*** Process after simulation selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_simulated_cuts", cut="simulated_cut", then="calibration_chain", else="io_output_simulated_non_selected")>>
#+END_SRC

*** Simulation chain
#+CAPTION: *Modules used by the simulation process.*
#+TBLNAME: simulation_chain
|-----------------------------|
| simulation                  |
| io_output_simulated         |
| process_with_simulated_cuts |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("simulation_chain", 3, simulation_chain)>>
#+END_SRC

*** Full chain (from simulation \to calibration \to reconstruction)
#+CAPTION: *Full chain processing.*
#+TBLNAME: full_chain
|-----------------------------|
| simulation_chain            |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("full_chain", 1, full_chain)>>
#+END_SRC

*** Minimum bias chain (from simulation \to calibration \to reconstruction)
#+CAPTION: *Full chain processing without selection.*
#+TBLNAME: minimum_bias_chain
|---------------------------|
| simulation                |
| add_header                |
| tracker_s2c               |
| calorimeter_s2c           |
| mock_tracker_clustering   |
| trackfit_tracker_fitting  |
| charged_particle_tracking |
| io_output_analysed        |
|---------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("minimum_bias_chain", 8, minimum_bias_chain)>>
#+END_SRC

*** Miscellaneous
#+CAPTION: *Reformating data.*
#+TBLNAME: reformat_data
|--------------------------------|
| remove_header                  |
| add_header                     |
| remove_mc_visu_hits            |
| remove_simulated_data          |
| remove_calibrated_data         |
| remove_tracker_clustering_data |
| remove_tracker_trajectory_data |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("reformat_data", 7, reformat_data)>>
#+END_SRC

* Services
:PROPERTIES:
:TANGLE: services.conf
:END:
A service generally hosts a specific resource that can be shared by many other
software components, including other services or data processing modules (see
[[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Whatisaservice][SN@ilWare FAQ]]).

#+NAME: service_preamble
#+BEGIN_SRC shell :results none :tangle no :exports none
  #@description A sample list of setups
  #@key_label   "name"
  #@meta_label  "type"
#+END_SRC

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

** Context service
#+BEGIN_SRC shell
  [name="Ctx" type="dpp::context_service"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description File from which the context is to be loaded at program start
  load.file : string as path  = "/tmp/${USER}/snemo.d/snemo_context.conf"

  #@description File to store the context at program termination
  store.file : string as path = "/tmp/${USER}/snemo.d/snemo_context_end.conf"

  #@description Flag to backup the former context load file
  backup.file : string as path = "/tmp/${USER}/snemo.d/snemo_context_bak.conf"
#+END_SRC

** Geometry service

The following code block declares the geometry service to properly load all the
geometry and material construction of the detector. This service, only declared
here, can be used by several operations like calibration, particle track
reconstruction ... but all of them will use the same geometry.

#+BEGIN_SRC shell
  [name="Geo" type="geomtools::geometry_service"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description Embedded SuperNEMO geometry manager main configuration file
  manager.configuration_file : string as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/sngeometry_manager.conf"
  # "@falaise:config/snemo/demonstrator/geometry/3.0/manager.conf"

  #@description Embedded SuperNEMO geometry manager must build its mapping lookup table
  manager.build_mapping : boolean = 1

  #@description Embedded geometry manager's mapping lookup table does not exclude any geometry category
  manager.no_excluded_categories : boolean = 1
#+END_SRC

** Cuts service

The [[https://nemo.lpc-caen.in2p3.fr/wiki/cuts][cuts]] package provides some basic classes and utilities to design, create and
apply selection cuts on arbitrary data models.

#+BEGIN_SRC shell
  [name="Cuts" type="cuts::cut_service"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The main configuration file for the embedded cut manager
  cut_manager.config : string as path = \
      "@SNEMO_SIMULATION_CONFIGURATION@/cut_manager.conf"
#+END_SRC

*** Manager configuration
:PROPERTIES:
:TANGLE: cut_manager.conf
:END:

#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = "warning"

  #@description Print a final report of cut efficiencies
  print_report : boolean = 1

  #@description Flag to skip the preloading of pre-registered cuts
  factory.no_preload : boolean = 0

  #@description A list of files that contains definition of cuts
  cuts.configuration_files : string[5] as path =                         \
    "@SNEMO_SIMULATION_CONFIGURATION@/simulated_data_cuts.conf"          \
    "@SNEMO_SIMULATION_CONFIGURATION@/calibrated_data_cuts.conf"         \
    "@SNEMO_SIMULATION_CONFIGURATION@/tracker_clustering_data_cuts.conf" \
    "@SNEMO_SIMULATION_CONFIGURATION@/tracker_trajectory_data_cuts.conf" \
    "@SNEMO_SIMULATION_CONFIGURATION@/particle_track_data_cuts.conf"
#+END_SRC

*** Skeleton codes                                               :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
This section provides some options to create and declare general cuts such as
checking bank availability. Since these tasks are quite generic and depends to
few parameters, the following code blocks provides easy interface to such cuts.

**** Skeleton code for ensuring data bank presence
This skeleton code allows to check the availability of a data bank.

#+NAME: has_bank
#+HEADERS: :var cname="" :var mode="has_bank" :var bname="" :var btype="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="dpp::utils_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check availabity of '$bname'"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description The running mode of this utils_cut instance'
  echo 'mode : string = "'$mode'"'
  echo
  echo '#@description The name of the bank to be checked (mandatory)'
  echo $mode'.name : string = "'$bname'"'
  if [ ! -z $btype ]; then
      echo
      echo '#@description The type (as a registered user string) of the bank to be checked (optional)'
      echo $mode'.type : string = "'$btype'"'
  fi
#+END_SRC

**** Skeleton code for =multi= cuts
#+NAME: multi
#+HEADERS: :var cname="" :var mode="and" :var ncut=0 :var list="cut1 cut2 cut3" :var logging="warning"
#+BEGIN_SRC shell
  vlist=(${=list})
  echo '[name="'$cname'" type="cuts::multi_'$mode'_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Multi-'$mode' cut"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = "'$logging'"'
  echo
  echo '#@description The cuts to be combined'
  echo 'cuts : string['$ncut'] = \'
  for i in $vlist
  do
      echo -n $i
      if [ $i != $vlist[-1] ]; then echo ' \';fi
  done
#+END_SRC

*** Simulated data selection
:PROPERTIES:
:TANGLE: simulated_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_simulated_data", bname="SD")>>
#+END_SRC

**** Multiple cuts
This cuts puts together all the previous declared cuts.
#+CAPTION: *Multi selection for validating simulation process.*
#+TBLNAME: simulated_cuts
|--------------------|
| has_simulated_data |
|--------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="simulated_cut", "and", 1, simulated_cuts)>>
#+END_SRC

*** Calibrated data selection
:PROPERTIES:
:TANGLE: calibrated_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_calibrated_data", bname="CD")>>
#+END_SRC

**** Check calibrated calorimeter availability
#+BEGIN_SRC shell
  [name="has_cd_calorimeter" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select calibrated calorimeter hit"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for a special boolean (flag) property
  mode.has_hit_category : boolean = 1

  #@description Name of the MC hit category to be checked
  has_hit_category.category : string = "calorimeter"
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_cd_calorimeter" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_cd_calorimeter"
#+END_SRC

**** Select number of calibrated calorimeter hits
#+BEGIN_SRC shell
  [name="cd_calorimeter_cut" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of calibrated calorimeter hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for multiplicity of calibrated hits
  mode.range_hit_category : boolean = 1

  #@description Name of the hit category to be checked
  range_hit_category.category : string = "calorimeter"

  #@description Minimal number of calibrated hits in the choosen category
  range_hit_category.min : integer = 2

  #@description Maximal number of calibrated hits in the choosen category
  range_hit_category.max : integer = 2
#+END_SRC

**** Check calibrated tracker availability
#+BEGIN_SRC shell
  [name="has_cd_tracker" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select calibrated tracker hit"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for a special boolean (flag) property
  mode.has_hit_category : boolean = 1

  #@description Name of the hit category to be checked
  has_hit_category.category : string = "tracker"
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_cd_tracker" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_cd_tracker"
#+END_SRC

**** Select number of calibrated tracker hits
#+BEGIN_SRC shell
  [name="cd_tracker_cut" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of calibrated tracker hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for multiplicity of calibrated hits
  mode.range_hit_category : boolean = 1

  #@description Name of the hit category to be checked
  range_hit_category.category : string = "tracker"

  #@description Minimal number of calibrated hits in the choosen category
  range_hit_category.min : integer = 3

  #@description Maximal number of calibrated hits in the choosen category
  #range_hit_category.max : integer = 1
#+END_SRC

**** Remove delayed calibrated tracker hits
#+BEGIN_SRC shell
  [name="has_delayed_tracker_hit" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select delayed calibrated tracker hit"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for delayed trait bit
  mode.tracker_hit_is_delayed : boolean = 1

  #@description Delayed time of the tracker hit
  tracker_hit_is_delayed.delay_time : real as time = 15 us
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_delayed_tracker_hit" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_delayed_tracker_hit"
#+END_SRC

**** Multiple cuts
This cuts puts together all the previous declared cuts.
#+CAPTION: *Multi selection for validating calibration process.*
#+TBLNAME: calibrated_cuts
|--------------------------|
| has_calibrated_data      |
| has_cd_calorimeter       |
| cd_calorimeter_cut       |
| has_cd_tracker           |
| cd_tracker_cut           |
| !has_delayed_tracker_hit |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="calibrated_cut", "and", 1, calibrated_cuts)>>
#+END_SRC

*** Tracker clustering data selection
:PROPERTIES:
:TANGLE: tracker_clustering_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_tracker_clustering_data", bname="TCD")>>
#+END_SRC

**** Check if clusters have been performed
#+BEGIN_SRC shell
  [name="has_cluster" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Check tracker cluster presence"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check of clusters presence
  mode.has_cluster : boolean = 1
#+END_SRC
**** Select number of cluster
#+BEGIN_SRC shell
  [name="cluster_range_cut" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of tracker clusters"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of clusters
  mode.range_cluster : boolean = 1

  #@description Minimal number of clusters
  range_cluster.min : integer = 2

  #@description Maximal number of clusters
  range_cluster.max : integer = 4
#+END_SRC

**** Select number of hit within a cluster                       :notused:
#+BEGIN_SRC shell :tangle no
  [name="tcd2_cut" type="snemo::analysis::cut::tracker_clustering_data_cut"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of clusters
  mode.range_tracker_hit : boolean = 1

  #@description Minimal number of cells in cluster
  range_tracker_hit.min : integer = 1

  # #@description Maximal number of cells in cluster
  # range_tracker_hit.max : integer = 100000
#+END_SRC

**** "Selecting" unclustered hits
We define a serie of cut to remove event with too much unclustered hits. We
first define a cut to check is there is some unclustered hits. If yes, then we
ask tracker cluster solution to have more than 4 unclustered hits. Finally,
since we want to remove thess events, we build a =nor_cut= to keep
***** Check if unclustered hits remain
#+BEGIN_SRC shell
  [name="has_unclustered_hits" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Check unclustered hits presence"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check of unclustered hits
  mode.has_unclustered_hits : boolean = 1
#+END_SRC
***** Select number of unclustered hits
#+BEGIN_SRC shell
  [name="unclustered_hits_range_cut" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of unclustered hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of unclustered hits
  mode.range_unclustered_hits : boolean = 1

  #@description Minimal number of unclustured hits
  range_unclustered_hits.min : integer = 4
#+END_SRC

***** No unclustered hits nor large number of unclustered hits
#+CAPTION: *Multi-selection for getting unclustering hits.*
#+TBLNAME: unclustered_hits_cuts
|----------------------------|
| has_unclustered_hits       |
| unclustered_hits_range_cut |
|----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="range_unclustered_hits", "and", 2, unclustered_hits_cuts)>>
#+END_SRC

Now that we have selected tracker clustering solution with large number of
unclustered hits, use the negation of this cut to keep event with low number of
unclustered hits.
#+BEGIN_SRC shell
  [name="!range_unclustered_hits" type="cuts::not_cut"]

  #@description Cut description
  cut.description : string = "Remove event with large number of unclustered hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description  The name of the cut to be negated
  cut : string = "range_unclustered_hits"
#+END_SRC

**** Multiple cuts
#+CAPTION: *Multi-selection for validating tracker clustering process.*
#+TBLNAME: tracker_clustering_cuts
|-----------------------------|
| has_tracker_clustering_data |
| has_cluster                 |
| cluster_range_cut           |
| !range_unclustered_hits     |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="tracker_clustering_cut", "and", 1, tracker_clustering_cuts)>>
#+END_SRC

*** Tracker trajectory data selection
:PROPERTIES:
:TANGLE: tracker_trajectory_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_tracker_trajectory_data", bname="TTD")>>
#+END_SRC

**** Multiple cuts
#+CAPTION: *Multi-selection for validating tracker trajectory process.*
#+TBLNAME: tracker_trajectory_cuts
|-----------------------------|
| has_tracker_trajectory_data |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="tracker_trajectory_cut", "and", 1, tracker_trajectory_cuts)>>
#+END_SRC

*** Particle track selection
:PROPERTIES:
:TANGLE: particle_track_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_particle_track_data", bname="PTD")>>
#+END_SRC

**** Check if particles have been reconstructed
#+BEGIN_SRC shell
  [name="has_particle" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select reconstructed particle"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for a special boolean (flag) propertyX
  mode.has_particles : boolean = 1
#+END_SRC
**** Select number of particles
#+BEGIN_SRC shell
  [name="range_particle" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select a number of particle tracks"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for multiplicity of particles trajectories
  mode.range_particles : boolean = 1

  #@description Minimal number of particle track
  range_particles.min : integer = 1

  # #@description Maximal number of particle track
  # range_particles.max : integer = 2
#+END_SRC

**** Check association with calorimeter hits
#+BEGIN_SRC shell
  [name="has_associated_calorimeter_hits" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select association particle/calorimeter hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for association between track and calorimeter hits
  mode.particle_has_associated_calorimeter_hits : boolean = 1
#+END_SRC

**** Select number of associated calorimeter hits
#+BEGIN_SRC shell
  [name="range_associated_calorimeter_hits" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select a number of associated calorimeter hits to one particle"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for multiplicity of associated calorimeter hits
  mode.particle_range_associated_calorimeter_hits : boolean = 1

  #@description Minimal number of associated calorimeter hits in the choosen category
  particle_range_associated_calorimeter_hits.min : integer = 1

  #@description Maximal number of associated calorimeter hits in the choosen category
  #particle_range_associated_calorimeter_hits.max : integer = 1
#+END_SRC

**** Check if track has foil vertex
#+BEGIN_SRC shell
  [name="has_vertex_on_foil" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select particle with vertex on the source foil"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for vertex extrapolation on source foil
  mode.particle_has_vertex_on_foil : boolean = 1
#+END_SRC

**** Select particle charge
#+BEGIN_SRC shell
  [name="has_negative_charge" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select only negative charge particle"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for a special boolean (flag) property
  mode.particle_has_charge : boolean = 1

  #@description Name of the MC hit category to be checked
  particle_has_charge.type : string = "negative"
#+END_SRC

#+BEGIN_SRC shell
  [name="has_positive_charge" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select only positive charge particle"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for a special boolean (flag) property
  mode.particle_has_charge : boolean = 1

  #@description Name of the MC hit category to be checked
  particle_has_charge.type : string = "positive"
#+END_SRC

#+BEGIN_SRC shell
  [name="has_undefined_charge" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select only undefined charge particle"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for a special boolean (flag) property
  mode.particle_has_charge : boolean = 1

  #@description Name of the MC hit category to be checked
  particle_has_charge.type : string = "undefined"
#+END_SRC

**** No isolated calorimeter hits
Remove event with non associated calorimeters hits.
#+BEGIN_SRC shell
  [name="has_non_associated_calorimeter_hits" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select event with non associated calorimeter hits"

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for non associated calorimeter hits
  mode.has_non_associated_calorimeter_hits : boolean = 1
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_non_associated_calorimeter_hits" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_non_associated_calorimeter_hits"
#+END_SRC
**** Reconstruction parameters selection                         :notused:
#+BEGIN_SRC shell
  [name="chi2_cut" type="snemo::analysis::cut::basic_particle_track_parameter_cut"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the parameter mode
  mode.parameter : boolean = 1

  #@description Parameter label (parameter can be either 'chi2',
  #'reduced_chi2', 'radius')
  parameter.label : string = "reduced_chi2"

  ##@description Parameter minimal value
  parameter.min : real = 0.0

  #@description Parameter minimal value
  parameter.max : real = 1000.0
#+END_SRC

#+BEGIN_SRC shell
  [name="deltay_calo_cut" type="snemo::analysis::cut::basic_particle_track_parameter_cut"]

  #@description Logging priority
  logging.priority : string = "warning"

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description The label/name of the 'particle track data' bank
  SD_label : string = "SD"

  #@description Activate the parameter mode
  mode.parameter : boolean = 1

  #@description Parameter label (parameter can be either 'vertex_on_foil',
  #'vertex_on_calorimeter')
  parameter.label : string = "vertex_on_calorimeter"

  #@description Parameter coordinate (either x, y or z)
  parameter.coordinate : string = "y"

  #@description Parameter minimal value
  parameter.min : real = 50.0 # mm

  # #@description Parameter minimal value
  # parameter.max : real = 10.0 # mm
#+END_SRC

**** Multiple cuts
#+CAPTION: *Multi-selection for validating particle tracking process.*
#+TBLNAME: particle_track_cuts
|--------------------------------------|
| has_particle_track_data              |
| has_particle                         |
| range_particle                       |
| has_associated_calorimeter_hits      |
| range_associated_calorimeter_hits    |
| has_vertex_on_foil                   |
| has_negative_charge                  |
| !has_non_associated_calorimeter_hits |
|--------------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("particle_track_cut", "and", 7, particle_track_cuts)>>
#+END_SRC
* Running SN@ilWare processing chain

Since this configuration will run through the executable =bxdpp_processing= from
Bayeux library and not through =flsimulate+flreconstruct= binaries from Falaise
library, we should take care of loading the proper libraries. This is
automatically done with the [[DLL loader]] code where library paths to be used by
this setup are explicitely set.

Running processing pipeline is done by the =bxdpp_processing= program provided
by =dpp= library. Its call is pretty simple and only implies to have a module
manager file. Nevertheless, since we do not rely to Falaise /i.e./ we do not use
=flsimulate+flreconstruct= we must set different resource paths (geometry,
materials). This is not user-friendly at all but this is the only way so far.

For example, if you only want to do simulation, you can run the following
command

#+BEGIN_SRC shell
  bxdpp_processing                                                                             \
      --module-manager-config ./current/module_manager.conf                                    \
      --module simulation                                                                      \
      --dlls-config ./current/dlls.conf                                                        \
      --datatools::resource_path="falaise@<falaise install dir>/share/Falaise-1.0.0/resources" \
      --max-records 100
#+END_SRC

An other way to run the previous command without loading the =dlls.conf= file
will be to temporarly set the =LD_LIBRARY_PATH= variable and to point it to the
=Falaise= and =Bayeux= libraries path namely
#+BEGIN_SRC shell
  LD_LIBRARY_PATH="<bayeux install dir>/bayeux/install/lib64:<falaise install dir>/falaise/install/lib64" \
  bxdpp_processing                                                                                        \
      --module-manager-config ./current/module_manager.conf                                               \
      --module simulation                                                                                 \
      --load-dll Bayeux_mctools_geant4 --load-dll Falaise                                                 \
      --datatools::resource_path="falaise@<falaise install dir>/share/Falaise-1.0.0/resources"            \
      --max-records 100
#+END_SRC

It will launch 100 simulated events using the =simulation_chain= module as
setup [[G4 simulation][in this section]].

In the same way you can run the calibration chain by doing

#+BEGIN_SRC shell
  bxdpp_processing                                                                             \
      --module-manager-config ./current/module_manager.conf                                    \
      --module calibration                                                                     \
      --dlls-config ./current/dlls.conf                                                        \
      --datatools::resource_path="falaise@<falaise install dir>/share/Falaise-1.0.0/resources" \
      --input-file /tmp/$USER/io_output_simulated.brio
#+END_SRC
where file =/tmp/$USER/io_output_simulated.brio= is the one produced by the
=simulation_chain= module as defined and setup [[Simulation output][in this section]].

All the different process steps can then be run using the dedicated module such
as [[Clustering algorithms][clustering]] or [[Fitting algorithm][fitting]] Geiger cells. The most complete mode is the
=full_chain= module where all process are done from simulation \to calibration \to
track reconstruction[4].

[3] Assuming you are using a recent version of =bash=. With =c-shell= and
derivatives, =export= is replace by =setenv=. Nevertheless, this setup has never
been tested under this shells.

[4] For such processing you will need additional libraries see [[DLL loader]].

#+TITLE:  SN@ilWare Simulation Configuration
#+AUTHOR: Xavier Garrido
#+DATE:   2013-02-22
#+OPTIONS: ^:{}
#+STARTUP: entitiespretty

* Introduction

This file contains a SN@ilWare configuration to run SuperNEMO simulations. The
current version is hosted at
[[https://github.com/xgarrido/snemo_simulation_configuration]] under =git= version
control. You can clone this repository by doing

#+BEGIN_SRC shell
  git clone https://github.com/xgarrido/snemo_simulation_configuration snemo_configuration
#+END_SRC

This will create a directory =snemo_configuration= in the working directory
containing all the source files needed to configure and to setup SN@ilWare
programs.

The configuration files are organised using [[http://orgmode.org/worg/org-contrib/babel/index.html][org-babel]] and its ability to execute
source code. It requires then a recent installation of emacs[1] which bundles
=org=. Without entering into too much details regarding =org-babel= abilities,
the basic idea is to give a "literate" way to navigate through the different
sections, each of them representing a configuration file. Moreover, using =org=
folding/unfolding capability, item can be hide and the user can focus on
relevant parts.

To export the different configuration files, you can run =org-babel-tangle=
which will tangle each code block into the given file[2] or use the associated
Makefile. The author recommends to use the Makefile since the tangling process
is asynchronous and thus, does not freeze your emacs (=org-babel-tangle=
"occupies" emacs during its execution).

[1] At the time of writing this document, emacs version is 24.2.
[2] Emacs lisp function can be run using =ALT-x= command and typing the function
name.

* Pipeline general configuration

SN@ilWare implements the concept of data processing pipeline. An event record
object is passed through a chain of data processing modules, each of them being
responsible for a given task. Modules and services are declared in Section
[[Modules]] and Section [[Services]]. For more details on running SuperNEMO simulations
and the concept behind modules/services see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=1889][these mandatory presentations]] given
by F. Mauger.

** Module manager
:PROPERTIES:
:TANGLE: module_manager.conf
:END:
This file is the main and central piece of code for loading all modules/services
needed by =dpp_processing= binary. It provides links to module files and
service files.
*** Logging priority
#+BEGIN_SRC shell
  #@description Module manager logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Embedded module factory debug flag
  factory.debug : boolean = false

  #@description Embedded module factory 'no preload' flag
  factory.no_preload : boolean = false
#+END_SRC

*** Service manager configuration
#+BEGIN_SRC shell
  #@description The configuration file of the embedded service manager
  service_manager.configuration : string[1] as path = \
      "@configuration:service_manager.conf"
#+END_SRC

*** Configuration files for modules
#+BEGIN_SRC shell
  #@description The configuration files for modules
  modules.configuration_files : string[12] as path =   \
      "@configuration:io_modules.conf"                 \
      "@configuration:utl_modules.conf"                \
      "@configuration:simulation_modules.conf"         \
      "@configuration:event_header_modules.conf"       \
      "@configuration:calibration_modules.conf"        \
      "@configuration:tracker_clustering_modules.conf" \
      "@configuration:tracker_fitting_modules.conf"    \
      "@configuration:particle_tracking_modules.conf"  \
      "@configuration:gamma_tracking_modules.conf"     \
      "@configuration:topology_modules.conf"           \
      "@configuration:chain_modules.conf"              \
      "@configuration:misc_modules.conf"
#+END_SRC

** Service manager
:PROPERTIES:
:TANGLE: service_manager.conf
:END:
*** Logging priority
#+BEGIN_SRC shell
  #@description Service manager logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC
*** Name & description
#+BEGIN_SRC shell
  #@description The name of the service manager
  name : string = "sn_service_manager"

  #@description The description of the service manager
  description : string = "A SuperNEMO service manager"
#+END_SRC
*** List of service files
#+BEGIN_SRC shell
  #@description The list of files that describe services
  services.configuration_files : string[1] as path = \
      "@configuration:services.conf"
#+END_SRC

** DLL loader
*** Code generator                                               :noexport:
:PROPERTIES:
:TANGLE:   no
:RESULTS:  output
:END:
This skeleton code ease the declaration of dll loader since it
receives a table list and builds the corresponding =dlls.conf= file.

#+NAME: dll_loader
#+HEADERS: :var name="" :var filename="" :shebang "#!/bin/bash"
#+BEGIN_SRC shell
  echo '#@description A sample list of setups'
  echo '#@key_label   "name"'
  echo '#@meta_label  "filename"'
  arr_name=(${name})
  arr_filename=($filename)
  for ((i=0; i < ${#arr_name[@]}; i++))
  do
      dll=${arr_name[$i]}
      dllpath=${arr_filename[$i]}
      if [ "$dllpath" != "none" ]; then
          echo '[name="'$dll'" filename="'$dllpath'"]'
      else
          echo '[name="'$dll'" filename=""]'
      fi
      echo '#config The '$dll' library'
      echo 'autoload : boolean = true'
      echo
  done
#+END_SRC
*** Libraries
:PROPERTIES:
:TANGLE: dlls.conf
:END:
This part set the different libraries to be loaded at runtime. This is needed
since event data models or algorithms may be defined in other libraries than the
=dpp= and inherited libraries. The following table sets a full (and exhaustive)
list of needed libraries

#+CAPTION: *Libraries to be used by modules.*
#+TBLNAME: dll_libraries
|-------------------------+-------------------------------------------------------------------------------------|
| Bayeux_mctools_geant4   | @snware:bayeux/install/lib64/libBayeux_mctools_geant4.so                            |
| Falaise                 | @snware:falaise/install/lib64/libFalaise.so                                         |
| Falaise_MTC             | @snware:falaise/install/lib64/Falaise/modules/libFalaise_MockTrackerClusterizer.so  |
| Falaise_CAT             | @snware:falaise/install/lib64/Falaise/modules/libFalaise_CAT.so                     |
| TrackFit                | @snware:falaise/install/lib64/Falaise/modules/libTrackFit.so                        |
| Falaise_TrackFit        | @snware:falaise/install/lib64/Falaise/modules/libFalaise_TrackFit.so                |
| Falaise_CPT             | @snware:falaise/install/lib64/Falaise/modules/libFalaise_ChargedParticleTracking.so |
| GammaTracking           | @snware:falaise/install/lib64/Falaise/modules/libGammaTracking.so                   |
| Falaise_GammaTracking   | @snware:falaise/install/lib64/Falaise/modules/libFalaise_GammaTracking.so           |
| Falaise_GammaClustering | @snware:falaise/install/lib64/Falaise/modules/libFalaise_GammaClustering.so         |
| Falaise_PID             | @snware:falaise/install/lib64/Falaise/modules/libFalaise_ParticleIdentification.so  |
| Falaise_ProcessReport   | @snware:falaise/install/lib64/Falaise/modules/libFalaise_ProcessReport.so           |
|-------------------------+-------------------------------------------------------------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<dll_loader(dll_libraries[*,0], dll_libraries[*,1])>>
#+END_SRC
* Modules

A data processing module is an object that performs some specific action (apply
an algorithm) on event records (see [[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Dataprocessingmodules][SN@ilWare FAQ]] for more details). It inherits
the =dpp::base_module= mother/interface class. A module class implements a few
mandatory methods :

- constructor
- destructor
- =initialize=
- =reset=
- =process=

The next items hold the configuration for several modules used in SN@ilWare
pipeline processing.

** Skeleton codes                                                 :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
This section provides some options to create and declare general modules such as
I/O modules (see Section [[I/O modules]]) or/and removing data bank. Since these
tasks are quite generic and depends to few parameters, the following code blocks
provides easy interface to such modules. The section [[I/O modules]] provides
example on how to use skeleton codes.

*** Skeleton code for output module
This skeleton code allows to define output module given the name of the
module. It also defines the output directory where to store each output steps.

#+NAME: output_module
#+HEADERS: :var mname="" :var logging="error" :var ofilename=""
#+BEGIN_SRC shell
    echo '[name="'$mname'" type="dpp::output_module"]'
    echo
    echo '#@description Logging priority'
    echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
    echo
    echo '#@description Output file mode'
    echo 'files.mode : string = "single"'
    echo
    echo '#@description Path to output data file'
    if [ -z ${ofilename} ]; then
        echo 'files.single.path : string as path = @variant(core:output_path|"/tmp/${USER}/snemo.d/")'
        echo
        echo '#@description Filename to output data file'
        echo 'files.single.filename : string = "'$mname'.brio"'
    else
        echo 'files.single.filename : string as path = "'$ofilename'"'
    fi
    echo
    echo '#@description The label of the Context service'
    echo 'Ctx_label : string  = "Ctx"'
#+END_SRC

*** Skeleton code for removing data bank

#+NAME: remove_module
#+HEADERS: :var mname="" :var mode="remove_banks" :var label="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$mname'" type="dpp::utils_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The processor mode'
  echo 'mode : string = "'$mode'"'
  echo
  echo '#@description The label to be removed'
  echo 'mode.'$mode'.labels : string[1] = "'$label'"'
#+END_SRC

*** Skeleton code for chain module
This skeleton code ease the declaration of =chain_module= processor since it
receives a table list and builds the =chain_module= declaration given its name.

#+NAME: chain_module
#+HEADERS: :var mname="" :var nmodule=0 :var list="module1 module2 module3" :var logging="warning"
#+BEGIN_SRC shell
  vlist=(${=list})
  echo '[name="'$mname'" type="dpp::chain_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The list of processing modules to be applied (in this order)'
  echo 'modules : string['$nmodule'] = \'
  for i in $vlist
  do
      echo -n \"$i\"
      if [ $i != $vlist[-1] ]; then echo ' \';fi
  done
#+END_SRC

*** Skeleton code for =if= module
This skeleton code is a template to declare =if_module= processor.

#+NAME: if_module
#+HEADERS: :var mname="" :var cut="" :var then="" :var else="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$mname'" type="dpp::if_module"]'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The label/name of the cut service'
  echo 'cut_service.label : string = "Cuts"'
  echo
  echo '#@description The name of the condition cut'
  echo 'condition_cut : string = "'$cut'"'
  echo
  echo '#@description The name of the module to be processed when condition is checked'
  echo 'then_module : string = "'$then'"'
  echo
  echo '#@description The name of the module to be processed when condition is NOT checked'
  echo 'else_module : string = "'$else'"'
#+END_SRC

** Mandatory preamble                                             :noexport:

This piece of code is not tangled by =org= but inserted into all module
preamble. This is mandatory in order to load properly and statically the
modules. Every module declared in this file must include this code block by
putting =<<module_preamble>>= in their module header declaration (before
anything else). The module code block should then use the =:noweb yes= option to
expand the =module_preamble= code.

#+NAME: module_preamble
#+BEGIN_SRC shell :results none :tangle no
  #@description A sample list of setups
  #@key_label   "name"
  #@meta_label  "type"
#+END_SRC

** I/O modules
:PROPERTIES:
:TANGLE: io_modules.conf
:END:

This section defines some I/O output modules to store data record. By default,
all I/O files are saved in =/tmp/${USER}/snemo.d= directory.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Simulation output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_simulated")>>
#+END_SRC

*** Calibration output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_calibrated")>>
#+END_SRC

*** Tracker clustering output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_tracker_clustering")>>
#+END_SRC

*** Tracker trajectory output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_tracker_trajectory")>>
#+END_SRC

*** Particle track output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_particle_track")>>
#+END_SRC

*** Analysis output
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_analysed")>>
#+END_SRC

*** Selection output

- Event header cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_header_selected")>>
    <<output_module("io_output_header_non_selected")>>
  #+END_SRC

- Simulation cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_simulated_selected")>>
    <<output_module("io_output_simulated_non_selected")>>
  #+END_SRC

- Calibration cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_calibrated_selected")>>
    <<output_module("io_output_calibrated_non_selected")>>
  #+END_SRC

- Tracking cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_tracker_clustering_selected")>>
    <<output_module("io_output_tracker_clustering_non_selected")>>
  #+END_SRC

- Fitting cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_tracker_trajectory_selected")>>
    <<output_module("io_output_tracker_trajectory_non_selected")>>
  #+END_SRC

- Particle track cuts
  #+BEGIN_SRC shell :noweb yes
    <<output_module("io_output_particle_track_selected")>>
    <<output_module("io_output_particle_track_non_selected")>>
  #+END_SRC

** Utility modules
:PROPERTIES:
:TANGLE: utl_modules.conf
:END:

Here we define some common and useful tasks such as removing data/MC hits.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Remove event header
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_header", label="EH", logging="warning")>>
#+END_SRC

*** Remove simulated data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_simulated_data", label="SD", logging="warning")>>
#+END_SRC
*** Remove calibrated data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_calibrated_data", label="CD", logging="warning")>>
#+END_SRC

*** Remove tracker clustering data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_tracker_clustering_data", label="TCD", logging="warning")>>
#+END_SRC
*** Remove tracker trajectory data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_tracker_trajectory_data", label="TTD", logging="warning")>>
#+END_SRC
*** Remove particle track data bank
#+BEGIN_SRC shell :noweb yes
  <<remove_module(mname="remove_particle_track_data", label="PTD", logging="warning")>>
#+END_SRC
*** Dump module
#+BEGIN_SRC shell
  [name="dump" type="dpp::dump_module"]

  #@description Output stream
  output : string = "clog"
#+END_SRC
*** Process report module
#+BEGIN_SRC shell
  [name="process_report" type="snemo::processing::process_report_module"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The geometry service label
  Geo_label : string = "Geo"

  #@description The cut service label
  Cut_label : string  = "Cuts"

  #@description Output stream
  output : string = "clog"

  #@description List of report drivers
  drivers : string[1] = "CRD"
#+END_SRC

**** Cut report driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority
  CRD.logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

***** Title/indent
#+BEGIN_SRC shell
  # #@description Title of the report
  # CRD.title : string = "* Cut report"

  #@description Indent of the report
  CRD.indent : string = "[notice]: "
#+END_SRC

***** Print report format
#+BEGIN_SRC shell
  #@description Cut report format
  CRD.print_report : string = "meter"
#+END_SRC

***** List of cuts to be shown
#+BEGIN_SRC shell
  #@description List of cut to show
  CRD.cuts : string[18] =                  \
           "2e::has_topology_data"         \
           "2e::has_pattern"               \
           "2e::has_classification"        \
           "2e::good_internal_probability" \
           "2e::bad_external_probability"  \
           "2e::channel_cut"               \
           "----------------------------"  \
           "2e1g::channel_cut"             \
           "----------------------------"  \
           "2e2g::channel_cut"             \
           "----------------------------"  \
           "1e::channel_cut"               \
           "----------------------------"  \
           "1e1g::channel_cut"             \
           "----------------------------"  \
           "1e2g::channel_cut"             \
           "----------------------------"  \
           "1e1a::channel_cut"
#+END_SRC

** Simulation module
:PROPERTIES:
:TANGLE: simulation_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
  #@variant_remove_quotes Remove quotes arround string property
#+END_SRC

*** G4 simulation
A processor that populate the event record =simulated data= bank with Geant4
output (see [[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Monte-Carloproduction][SN@ilWare FAQ]]).
#+BEGIN_SRC shell
  [name="simulation" type="mctools::g4::simulation_module"]
#+END_SRC

**** Logging flag
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The simulation manager logging priority
  manager.logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC
**** Bank & service labels
#+BEGIN_SRC shell
  #@description The Geometry Service label
  Geo_label : string = "Geo"

  #@description The 'Simulated data' bank label in the event record
  SD_label  : string = "SD"

  #@description Flag to allow cleaning of some former simulated data bank if any (default: 0)
  erase_former_SD_bank : boolean = false
#+END_SRC
**** Seed values
#+BEGIN_SRC shell
  #@description The simulation manager PRNG seed
  manager.seed : integer = @variant(core:random_seed_flag/if_random_seed/null_seed|2)

  #@description The vertex generator PRNG seed
  manager.vertex_generator_seed : integer = @variant(core:random_seed_flag/if_random_seed/null_seed|4)

  #@description The event generator PRNG seed
  manager.event_generator_seed  : integer = @variant(core:random_seed_flag/if_random_seed/null_seed|5)

  #@description The SHPF PRNG seed
  manager.shpf_seed : integer = @variant(core:random_seed_flag/if_random_seed/null_seed|6)

  #@description The saving of PRNG seeds
  manager.output_prng_seeds_file : string as path = @variant(core:output_path)@variant(core:filename|"prng_seeds.save")

  #@description The saving of PRNG states
  manager.output_prng_states_file : string as path = @variant(core:output_path)@variant(core:filename|"prng_states.save")

  #@description The modulo for PRNG states backup
  manager.prng_states_save_modulo : integer = 10
#+END_SRC
**** Vertex generator
Several common vertex generators are available such as :
- tracker_gas_bulk,
- source_strips_bulk,
- source_strips_surface.

#+BEGIN_SRC shell
  #@description The vertex generator PRNG label
  manager.vertex_generator_name : string  = @variant(simulation:vertex_generator_name|"source_strips_bulk")
#+END_SRC

**** Event generator
Most used event generators are :
- Se82.0nubb,
- Bi214_Po214,
- Tl208,
- multi_particles,
- multi_gamma_particles,
- electron_monokinetic,
- alpha_monokinetic.

#+BEGIN_SRC shell
  #@description The event generator PRNG label
  manager.event_generator_name : string  = @variant(simulation:event_generator_name|"Se82.0nubb")
#+END_SRC
**** G4 manager
The full =geant4= configuration can be found in the [[file:./sng4_manager.org][sng4_manager]] file.
#+BEGIN_SRC shell
  #@description The simulation manager configuration file
  manager.configuration_filename : string as path = \
      "@configuration:sng4_manager.conf"
#+END_SRC

** Event header module
:PROPERTIES:
:TANGLE: event_header_modules.conf
:END:

After Geant4 simulation, no event header is added and available in the event
record. This module adds some information related either to real data (run
number) or simulated data like =genbb= weight in case the total energy of primary
particles has been restricted.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** General informations
#+BEGIN_SRC shell
  [name="add_header" type="snemo::processing::event_header_utils_module"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The processor mode
  mode : string = "add_header"

  #@description The label of the 'Event Header' bank
  add_header.bank_label : string = "EH"

  #@description The run number
  add_header.run_number : integer = 0

  #@description The number of the first event number to be set
  add_header.event_number : integer = 0

  #@description The event weight given by GENBB and used for 'energy_range' mode
  add_header.use_genbb_weight : boolean = true

  #@description The event label from GENBB settings
  add_header.use_genbb_label  : boolean = true
#+END_SRC

Among the options offered by =event_header_utils_module=, there is a possibility
to give an external file (following =datatools::properties= writing conventions)
where additionnal informations can be added. Typical use case is the definition
of some properties/descriptions of simulation runs (see below).

The =external_properties_prefix= allows to filter which properties should be
stored. If no =external_properties_prefix= field is defined then all the
properties are used and serialized.

#+BEGIN_SRC shell
  #@description The external properties files to be exported in event_header properties
  add_header.external_properties_path : string as path = \
      "@configuration:snsimulation_header.conf"

  #@description The external properties prefix to export only properties starting with this prefix
  add_header.external_properties_prefix : string = "analysis"
#+END_SRC

*** Analysis informations
:PROPERTIES:
:TANGLE: snsimulation_header.conf
:END:
**** Getting branch status                                      :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
The following code block allows to "tag" the current version /i.e./ getting the
=git= branch name, commit chunk

#+NAME: vc-status
#+BEGIN_SRC shell
  if [ -d .git ]; then
      log+="git "$(git rev-parse --abbrev-ref HEAD)" branch - "
      log+=$(LC_MESSAGES=en git --no-pager log -1 HEAD --date=short --pretty=format:"commit %h - %ad")
      echo -n $log
  fi
#+END_SRC

**** Getting component version                                  :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
The following code block retrieves the version number of a given component
#+NAME: code-version
#+HEADERS: :var name="" :var binary=1
#+BEGIN_SRC shell :noweb yes
  if [ "$name" != "" ]; then
      if [ $binary -eq 1 ]; then
          echo -n "$($name-config --version)"
      else
          cd $($name-config --prefix)/..
          status=$(LC_MESSAGES=en git svn info)
          rev=$(echo -e $status | sed -n 's/.*Revision: *\([^ ]*\).*/\1/p')
          date=$(echo -e $status | sed -n 's/.*Last Changed Date: *\([^ ]*\).*/\1/p')
          log="svn revision ${rev} - ${date}"
          echo -n $log
      fi
  fi
#+END_SRC
**** Store the current =git= version of the configuration
#+BEGIN_SRC shell :noweb yes
  #@description The version control status
  analysis.vc_status : string = "<<vc-status()>>"
#+END_SRC

**** Set analysis description
#+BEGIN_SRC shell
  #@description The analysis description
  analysis.description : string = "Sensitivity studies for SuperNEMO demonstrator"
#+END_SRC

**** Store the total number of event simulated
#+BEGIN_SRC shell
  #@description The total number of event simulated
  analysis.total_number_of_event : real = @variant(simulation:total_number_of_event|1)
#+END_SRC

**** Store the geometrical origin of the vertex
#+BEGIN_SRC shell
  #@description Vertex generator name
  analysis.vertex_generator_name : string = @variant(simulation:vertex_generator_name|"not available")
#+END_SRC

**** Store the event generator
This can be done through the =use_genbb_label= property of
=event_header_utils_module= but here we do it thanks to =variant= keyword
#+BEGIN_SRC shell
  #@description Event generator name
  analysis.event_generator_name : string = @variant(simulation:event_generator_name|"not available")
#+END_SRC

**** Store the job id
When simulations are done @ Lyon and send to the Grid Engine, every process get
a unique job-ID. We store it within the event header in order to get back to the
simulation setup if needed.
#+BEGIN_SRC shell
  #@description The job-ID of the process
  analysis.jobid : integer = 0
#+END_SRC
*** Update informations
#+BEGIN_SRC shell
  [name="update_header" type="snemo::processing::event_header_utils_module"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The processor mode
  mode : string = "add_header"

  #@description The label of the 'Event Header' bank
  add_header.bank_label : string = "EH"

  #@description Update flag
  add_header.update : boolean = true

  #@description The external properties files to be exported in event_header properties
  add_header.external_properties_path : string as path = \
      "@configuration:snsimulation_header.conf"

  #@description The external properties prefix to export only properties starting with this prefix
  add_header.external_properties_prefix : string = "analysis"
#+END_SRC

** Calibration modules
:PROPERTIES:
:TANGLE: calibration_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Tracker simulation to calibration data
:PROPERTIES:
:CUSTOM_ID: tracker_s2c
:END:

This module converts simulated data into calibrated data for SuperNEMO
tracker. It is a mock digitization/calibration data module of Monte-Carlo
hits. It applies some anode/cathode efficiencies as well as calibration and
smearing curves to translate times into longitudinal and transerve
positions. Main reference documents for this module can be find in DocDb [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=786][#786]]
and [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=843][#843]].

#+BEGIN_SRC shell
  [name="tracker_s2c" type="snemo::processing::mock_tracker_s2c_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

**** Data bank labels and hit category
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Simulated Data' bank
  SD_label : string  = "SD"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The category of hits to be processed as Geiger hits
  hit_category  : string  = "gg"
#+END_SRC

**** Random generator
#+BEGIN_SRC shell
  #@description Pseudo-random numbers generator setup
  random.id   : string  = "mt19937"
  random.seed : integer = 12345
#+END_SRC

**** Geiger cells dimensions
#+BEGIN_SRC shell
  #@description Drift cell effective/active diameter
  cell_diameter : real as length = 44.0 mm

  #@description Drift cell effective/active length
  cell_length : real as length = 2900.0 mm
#+END_SRC

**** Anode/cathode efficiencies
#+BEGIN_SRC shell
  #@description anode efficiency
  base_anode_efficiency   : real = 1.0

  #@description cathode efficiency
  base_cathode_efficiency : real = 1.0
#+END_SRC
**** Plasma longitudinal speed
#+BEGIN_SRC shell
  #@description plasma longitudinal speed
  plasma_longitudinal_speed : real as velocity = 5.0 cm/us
#+END_SRC

**** Longitudinal & transerve reconstruction parameters
#+BEGIN_SRC shell
  #@description Error on reconstructed longitudinal position (from a plot by Irina)
  sigma_z : real as length = 1.0 cm # (to be confirmed)

  #@description Error on reconstructed longitudinal position when one cathode signal is missing
  sigma_z_missing_cathode  : real as length = 5.0 cm # (to be confirmed)

  #@description Error on reconstructed horizontal position (parameters of a fit of data by Irina)
  sigma_r_a  : real as length = 0.425 mm
  sigma_r_b  : real = 0.0083
  sigma_r_r0 : real as length = 12.25 mm
#+END_SRC

**** Delayed drift time threshold
#+BEGIN_SRC shell
  # #@description Time threshold to tag Geiger cells as delayed
  # delayed_drift_time_threshold : real as time = 10 us
#+END_SRC
*** Calorimeter simulation to calibration data

This module converts Monte-Carlo hits into calorimeter hits. Like the previous
[[#tracker_s2c][section]], it is a mock digitization/calibration of simulation hits. It basicaly
aggregates several energy deposits, calculates the total energy deposited and
the time of the first energy deposit and finally, it smears the energy and time
by some experimental energy/time resolution. There is also a special treatments
for the quenching of alpha particles.

#+BEGIN_SRC shell
  [name="calorimeter_s2c" type="snemo::processing::mock_calorimeter_s2c_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

**** Data bank labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Simulated Data' bank
  SD_label : string  = "SD"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"
#+END_SRC
**** Random generator
#+BEGIN_SRC shell
  #@description Pseudo-random numbers generator setup
  random.id   : string  = "mt19937"
  random.seed : integer = 12345
#+END_SRC

**** Activate \alpha quenching
#+BEGIN_SRC shell
  #@description Alpha quenching boolean
  alpha_quenching : boolean = true
#+END_SRC
**** Calorimeter regimes
***** Hit categories
#+BEGIN_SRC shell
  #@description The categories of hits to be processed as calorimeter hits
  hit_categories  : string[3]  = "calo" "xcalo" "gveto"
#+END_SRC
***** \alpha quenching parameters
We do not use these parameters
#+BEGIN_SRC shell
  #@description Alpha quenching parameters
  calo.alpha_quenching_parameters  : real[3] = 77.4 0.639 2.34
  xcalo.alpha_quenching_parameters : real[3] = 77.4 0.639 2.34
  gveto.alpha_quenching_parameters : real[3] = 77.4 0.639 2.34
#+END_SRC

***** Scintillator relaxation time for time resolution
#+BEGIN_SRC shell
  #@description Time resolution parameters
  calo.scintillator_relaxation_time  : real as time = 6.0 ns
  xcalo.scintillator_relaxation_time : real as time = 6.0 ns
  gveto.scintillator_relaxation_time : real as time = 6.0 ns
#+END_SRC

***** Energy resolutions
#+BEGIN_SRC shell
  #@description Optical lines resolutions (FWHM @ 1 MeV)
  calo.energy.resolution  : real as fraction = @variant(detector:calo_energy_resolution|8 %)
  xcalo.energy.resolution : real as fraction = @variant(detector:xcalo_energy_resolution|12 %)
  gveto.energy.resolution : real as fraction = @variant(detector:gveto_energy_resolution|15 %)
#+END_SRC

***** Energy thresholds
#+BEGIN_SRC shell
  #@description Optical lines trigger thresholds
  calo.energy.high_threshold  : real as energy = @variant(detector:calo_high_energy_threshold|150 keV)
  xcalo.energy.high_threshold : real as energy = @variant(detector:xcalo_high_energy_threshold|150 keV)
  gveto.energy.high_threshold : real as energy = @variant(detector:gveto_high_energy_threshold|150 keV)

  calo.energy.low_threshold   : real as energy = @variant(detector:calo_low_energy_threshold|50 keV)
  xcalo.energy.low_threshold  : real as energy = @variant(detector:xcalo_low_energy_threshold|50 keV)
  gveto.energy.low_threshold  : real as energy = @variant(detector:gveto_low_energy_threshold|50 keV)
#+END_SRC

** Tracker clustering modules
:PROPERTIES:
:TANGLE: tracker_clustering_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Clustering algorithms

This section holds different modules all related to tracker clustering.

**** Mock tracker clustering

This algorithm is too much simple but it can serve as a comparison point with
respect to more elaborated algorithms in terms of time processing. It basically
associates geiger cells but considering succesive neighbors. It does not use the
longitudinal information and then can badly aggregates track belonging to two
different particles.

#+BEGIN_SRC shell
  [name="mock_tracker_clustering" type="snemo::reconstruction::mock_tracker_clustering_module"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Tracker Clusterizer logging priority
  BTC.logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = true

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = true

  #@description Maximum layer distance between two neighbour hits
  MTC.max_layer_distance : integer = 2

  #@description Maximum row distance between two neighbour hits
  MTC.max_row_distance   : integer = 2

  #@description Maximum row+layer distance between two neighbour hits
  MTC.max_sum_distance   : integer = 0
#+END_SRC

# We also add an option to not split the tracker chamber when pre clustering is
# done by =TrackerPreClusterizer=. This option is set to true by default but here
# with the =mock_tracker_clustering_module= it does not make sense since cells are
# already ordered by time. So to avoid confusion (especially to avoid double
# tracker clustering solution), we do not ak pre-clustering to split the chamber.

# #+BEGIN_SRC shell
#   #@description Tracker pre clusterizer splitting chamber option
#   TPC.split_chamber : boolean = false
# #+END_SRC

**** Cellular Automaton Tracker

This algorithm provides tons of parameters and is based in F. Nova work. A
somewhat complete overview of CAT main features can be seen in DocDb [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2120][#2120]].

#+BEGIN_SRC shell
  [name="cat_tracker_clustering" type="snemo::reconstruction::cat_tracker_clustering_module"]

  #@description Logging support
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Tracker Clusterizer logging priority
  BTC.logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Drift cell selection rules
  #BTC.cell_id_mask_rules : string = "category='drift_cell_core' module={*} side={*} layer=[6;8] row={*}"
  BTC.cell_id_mask_rules : string = "category='drift_cell_core' module={*} side={*} layer={*} row={*}"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = true

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = true

  # #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  # TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Pre-clusterizer processing separately both sides of the tracking chamber
  TPC.split_chamber : boolean = false

  #@description CAT logging level
  CAT.level : string = "mute"

  # #@description Force the CAT algorithm to consider a 25 gauss magnetic field (temporary trick)
  # CAT.magnetic_field : real = 25 gauss

  #@description Use calorimeter hits information to help clustering
  CAT.process_calo_hits : boolean = true

  #@description Store CAT results as data properties
  CAT.store_result_as_properties : boolean = false
#+END_SRC

**** SULTAN tracker

Federico Nova recently implements a new way to cluster Geiger cells by
translating their intrinsic parameters namely cell position, drift radius and
azimuthal position in Legendre phase space. The idea was originally suggested by
Yorck Ramachers (see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2556][DocDB 2256]]) and Federico added the ability to fit helix
(see [[http://nile.hep.utexas.edu/cgi-bin/DocDB/ut-nemo/private/ShowDocument?docid=2977][DocDB 2977]] as well as the [[http://www.sciencedirect.com/science/article/pii/S0168900208005780][original paper]]).

#+BEGIN_SRC shell
  [name="sultan_tracker_clustering" type="snemo::reconstruction::sultan_tracker_clustering_module"]

  #@description Logging support
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = true

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = false

  # #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  # TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Activation of the clustering of delayed hits
  TPC.split_chamber : boolean = false

  #@description Use calorimeter hits information to help clustering
  SULTAN.process_calo_hits : boolean = true

  # #@description Clusterize with helix model
  # SULTAN.clusterize_with_helix_model : boolean = true

  # #@description Force the SULTAN algorithm to consider a 25 gauss magnetic field (temporary trick)
  # SULTAN.magnetic_field : real = 25 gauss

  # #@description To be described
  # SULTAN.max_time : real = 5000 ms

  # #@description Use online event display (devel only)
  # SULTAN.print_event_display : boolean = false

  # #@description To be described
  # SULTAN.Emin : real  = 120 keV

  # #@description To be described
  # SULTAN.Emax : real  = 3.3 MeV

  # #@description To be described
  # SULTAN.nsigma_r : real  = 3.0

  # #@description To be described
  # SULTAN.nsigma_z : real  = 4.0

  # #@description To be described
  # SULTAN.nofflayers : integer = 1

  # #@description To be described
  # SULTAN.first_event : integer = -1

  # #@description To be described
  # SULTAN.min_ncells_in_cluster : integer = 7

  # #@description To be described
  # SULTAN.ncells_between_triplet_min : integer = 1

  # #@description To be described
  # SULTAN.ncells_between_triplet_range : integer = 3

  # #@description To be described
  # SULTAN.nsigmas : real  = 1.0

  # #@description To be described
  # SULTAN.sigma_z_factor : real  = 1.0

  # #@description Clusterize with endpoints
  # SULTAN.use_endpoints : boolean = true

  # #@description Clusterize with Legendre transform
  # SULTAN.use_legendre : boolean = false

  # #@description Use clocks to time different parts of the software
  # SULTAN.use_clocks : boolean = false
#+END_SRC

**** Tracker Cluster Path                                     :notworking:
This algorithm has been developped by Warwick group since June 2012 and mainly
by K. Bhardwaj.

#+BEGIN_SRC shell
  [name="tcp_tracker_clustering" type="snemo::reconstruction::processing::tracker_clustering_module"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Event Header' bank
  EH_label : string  = "EH"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description The ID of the tracker hits clustering algorithm
  algorithm : string  = "TCP"

  #@description The module number
  module_number : integer = 0

  #@description The geometry category of the Geiger drift volume
  gg_cell_geom_category : string = "drift_cell_core"

  #@description Activation of the clustering of prompt hits
  TPC.processing_prompt_hits : boolean = true

  #@description Activation of the clustering of delayed hits
  TPC.processing_delayed_hits : boolean = true

  #@description The time width of the window for collecting candidate clusters of delayed hits (in microsecond)
  TPC.delayed_hit_cluster_time : real = 10.0 # microsec

  #@description Activation of the clustering of delayed hits
  TPC.split_chamber : boolean = true

  #@description TCP param
  TCP.gamma : integer = 3

  #@description TCP param
  TCP.lambda : real = 0.1

  #@description TCP param
  TCP.join_threshold : real = 0.70

  #@description TCP param
  TCP.opt_threshold : real = 0.00001

  #@description TCP param
  TCP.lambda_factor : real = 1.05

  #@description TCP param
  TCP.smooth : integer = 0

  #@description TCP param
  TCP.max_iterations : integer = 1000

  #@description TCP param
  TCP.line_search_freq : integer = 2

  #@description TCP param
  TCP.line_search_points : integer = 10

  #@description TCP param
  TCP.check_splits : integer = 1

  #@description TCP param
  TCP.target_cluster : integer = 0

  #@description TCP param
  TCP.max_number_of_clusters_allowed : integer = 3

  #@description TCP param
  TCP.verbose : integer = 0

  #@description TCP param
  TCP.refinement_no : integer = 5

  #@description TCP param
  TCP.line_tolerance : real = 0.39

  #@description TCP param
  TCP.point_tolerance : real = 100
#+END_SRC

** Tracker fitting module
:PROPERTIES:
:TANGLE: tracker_fitting_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Fitting algorithm
As the time of writing this document, there is only one algorithm well
integrated into SN@ilWare pipeline. It is based on [[https://nemo.lpc-caen.in2p3.fr/wiki/trackfit][trackfit]] originally
developped and tested on NEMO3 data. It is quite an agnostic algorithm in the
sense that it only asked for cells position and drift radius. Fitting process is
done by GSL minimizer to find the global solution given the model: either helix
or line models.

#+BEGIN_SRC shell
  [name="trackfit_tracker_fitting" type="snemo::reconstruction::trackfit_tracker_fitting_module"]
#+END_SRC

**** General logging
#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

**** Data bank & services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Tracker Clustering Data' bank
  TCD_label : string  = "TCD"

  #@description The label of the 'Tracker Trajectory Data' bank
  TTD_label : string  = "TTD"
#+END_SRC

**** General options
#+BEGIN_SRC shell
  #@description Tracker fitter logging priority
  BTF.logging.priority : string = @variant(core:logging_priority|"error")

  #@description The maximum number of fits to be saved (0 means all will be kept)
  BTF.maximum_number_of_fits : integer = 0
#+END_SRC

**** Trackfit algorithm
#+BEGIN_SRC shell
  #@description The ID of the tracker fitting algorithm
  algorithm : string  = "trackfit"
#+END_SRC

***** Drift time calibration
For time delayed cluster like alpha particle track, a /a posteriori/ drift time
calibration has to be done to shift the time origin and then calculates the new
cell radius. The =drift_time_calibration= can be anything if it respects some
object interface rules defines in =trackfit::i_drift_time_calibration=
class. Here we use the same model as in Section [[Tracker simulation to calibration data]].
#+BEGIN_SRC shell
  #@description Use drift time (re)calibration
  drift_time_calibration_label : string = "snemo"
#+END_SRC

***** Fit models
#+BEGIN_SRC shell
  #@description Fit models
  fitting_models : string[2] = "line" "helix"
#+END_SRC
***** Line fit parameters
****** Guess parameters
#+BEGIN_SRC shell
  #@description Activate logging messages for line guess driver
  line.guess.logging.priority  : string = @variant(core:logging_priority|"error")

  #@description Use max radius (cell size) to construct initial guess point (1) or use the effective drift Geiger distance of the hit (0)
  line.guess.use_max_radius    : boolean = false

  #@description Apply a factor (>0) to the max radius (devel mode)
  line.guess.max_radius_factor : real = 1.0

  #@description Use guess trust (1) or keep all of the guess fits (0) and select later
  line.guess.use_guess_trust   : boolean = false

  #@description Mode for trusting a fit guess ("counter", "barycenter")
  line.guess.guess_trust_mode  : string = "counter"

  #@description Fit the delayed geiger cluster
  line.guess.fit_delayed_clusters : boolean = true
#+END_SRC

****** Fit parameters
#+BEGIN_SRC shell
  #@description 'Line' fit only guess ("BB", "BT", "TB", "TT")
  #line.only_guess : string[1] = "TT"

  #@description Store only the N solutions with best line fit
  #line.store_number_of_solutions : integer = 2

  #@description Print the status of the fit stepper at each step (devel only)
  line.fit.step_print_status : boolean = false

  #@description Plot the 2D view of the fitted data at each step (devel only)
  line.fit.step_draw         : boolean = false

  #@description Track fit adds start time as an additionnal parameter to the fit (needs a calibration driver)
  line.fit.fit_start_time    : boolean = false

  #@description Track fit recomputes the drift distance from drift time (needs a calibration driver)
  line.fit.using_drift_time  : boolean = false

  #@description Allow a fitted track to begin not tangential to the first hit
  line.fit.using_first       : boolean = false

  #@description Allow a fitted track to end not tangential to the last hit
  line.fit.using_last        : boolean = false
#+END_SRC
***** Helix fit parameters
****** Guess parameters
#+BEGIN_SRC shell
  #@description Activate logging messages for helix guess driver
  trackfit.helix.guess.logging.priority  : string = @variant(core:logging_priority|"error")

  #@description Use max radius (cell size) to construct initial guess point (1) or use the effective drift Geiger distance of the hit (0)
  trackfit.helix.guess.use_max_radius    : boolean = false

  #@description Apply a factor (>0) to the max radius (devel mode)
  trackfit.helix.guess.max_radius_factor : real = 1.0

  #@description Use guess trust (1) or keep all of the guess fits (0) and select later
  trackfit.helix.guess.use_guess_trust   : boolean = false

  #@description Mode for trusting a fit guess ("counter", "barycenter")
  trackfit.helix.guess.guess_trust_mode  : string = "counter"

  #@description Fit the delayed geiger cluster (by default, false since this mode is devoted to line fit)
  trackfit.helix.guess.fit_delayed_clusters : boolean = false
#+END_SRC
****** Fit parameters
#+BEGIN_SRC shell
  #@description 'Helix' fit only guess ("BBB", "BBT", "BTB", "BTT", "TBB", "TBT", "TTB", "TTT")
  #trackfit.helix.only_guess : string[1] = "TTT"

  #@description Store only the N solutions with best helix fit
  #trackfit.helix.store_number_of_solutions : integer = 2

  #@description Print the status of the fit stepper at each step (devel only)
  trackfit.helix.fit.step_print_status : boolean = false

  #@description Plot the 2D view of the fitted data at each step (devel only)
  trackfit.helix.fit.step_draw         : boolean = false

  #@description Track fit recomputes the drift distance from drift time (needs a calibration driver)
  trackfit.helix.fit.using_drift_time  : boolean = false

  #@description Allow a fitted track to begin not tangential to the first hit
  trackfit.helix.fit.using_first       : boolean = false

  #@description Allow a fitted track to end not tangential to the last hit
  trackfit.helix.fit.using_last        : boolean = false
#+END_SRC

** Charged particle tracking module
:PROPERTIES:
:TANGLE: particle_tracking_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Charged particle tracking
Given results of the two previous steps /i.e./ clustering and fitting, the
trajectories must be interpreted within SuperNEMO detector geometry. The
particle tracking translates trajectory into particle tracks and then determines
the track charge (assuming particle comes from the source foil), it extrapolates
track intersection with calorimeter walls and finally it associates particle
track with calorimeter blocks.

#+BEGIN_SRC shell
  [name="charged_particle_tracking" type="snemo::reconstruction::charged_particle_tracking_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC
**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Calibrated Data' bank
  CD_label : string  = "CD"

  #@description The label of the 'Tracker Trajectory Data' bank
  TTD_label : string  = "TTD"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string  = "PTD"
#+END_SRC
**** Drivers
The particle track reconstruction is done within several drivers, each one
having a dedicated tasks such as to compute track charge or to associate
particle track with calorimeter block. The way to perform these "actions" is
then decorelated with the pipeline execution. Other algorithms can be
implemented but the particle tracking module will stay unchanged.
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  drivers : string[4] = "VED" "CCD" "CAD" "AFD"
#+END_SRC

***** Vertex Extrapolation Driver
#+BEGIN_SRC shell
  #@description Vertex Extrapolation Driver logging priority
  VED.logging.priority : string = @variant(core:logging_priority|"error")

  #@description Use linear extrapolation (not implemented yet)
  VED.use_linear_extrapolation : boolean = false
#+END_SRC

***** Charge Computation Driver
#+BEGIN_SRC shell
  #@description Charge Computation Driver logging priority
  CCD.logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Charge sign convention
  CCD.charge_from_source : boolean = true
#+END_SRC

***** Calorimeter Association Driver
#+BEGIN_SRC shell
  #@description Calorimeter Association Driver logging priority
  CAD.logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Maximum matching distance for track/calo association
  CAD.matching_tolerance : real as length = 100 mm

  #@description Use a simpler approach by looking for gieger cells in front of calo (not implemented yet)
  CAD.use_last_geiger_cell : boolean = false
#+END_SRC
***** Alpha Finder Driver
#+BEGIN_SRC shell
  #@description Alpha Finder Driver logging priority
  AFD.logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC
** \gamma tracking module
:PROPERTIES:
:TANGLE: gamma_tracking_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** \gamma clustering

#+BEGIN_SRC shell
  [name="gamma_clustering" type="snemo::reconstruction::gamma_clustering_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string  = "PTD"
#+END_SRC

**** Default options
#+BEGIN_SRC shell
  #@description Gamma algorithm logging priority
  BGB.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC
**** Allow the extrapolation to the source foil
#+BEGIN_SRC shell
  #@description Enable the extrapolation to the source foil
  BGB.add_foil_vertex_extrapolation : boolean = true

  #@description Minimal internal probability for foil vertex extrapolation
  BGB.add_foil_vertex_extrapolation.minimal_probability : real as fraction = 1 %
#+END_SRC
**** Search for gamma from e+/e- annihilation
#+BEGIN_SRC shell
  #@description Enable the search for gamma from annihilation
  BGB.add_gamma_from_annihilation : boolean = true

  #@description Minimal internal probability for gamma from annihilation
  BGB.add_gamma_from_annihilation.minimal_probability : real as fraction = 1 %
#+END_SRC
**** Selection of calorimeter hits
#+BEGIN_SRC shell
  #@description Enable selection of calorimeter hits
  BGB.select_calorimeter_hits : boolean = true

  #@description Calorimeter tags
  BGB.select_calorimeter_hits.tags : string[2] = "__isolated" "__neighbour"
#+END_SRC
**** Driver
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  driver : string = "GC"
#+END_SRC

**** Cluster properties
#+BEGIN_SRC shell
  #@description The time spread between calorimeter hits within a cluster
  GC.cluster_time_range : real as time = 2.5 ns

  #@description The geometrical condition to cluster calorimeter hits ("side", "diagonal", "first", "second")
  GC.cluster_grid_mask : string = "first"
#+END_SRC

*** \gamma tracking

#+BEGIN_SRC shell
  [name="gamma_tracking" type="snemo::reconstruction::gamma_tracking_module"]
#+END_SRC

**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC
**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Geometry service
  Geo_label : string  = "Geo"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string  = "PTD"
#+END_SRC

**** Driver
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  driver : string = "GT"
#+END_SRC

**** Default options
#+BEGIN_SRC shell
  #@description Gamma algorithm logging priority
  BGB.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC
**** Allow the extrapolation to the source foil
#+BEGIN_SRC shell
  #@description Enable the extrapolation to the source foil
  BGB.add_foil_vertex_extrapolation : boolean = true

  #@description Minimal internal probability for foil vertex extrapolation
  BGB.add_foil_vertex_extrapolation.minimal_probability : real as fraction = 1 %
#+END_SRC
**** Selection of calorimeter hits
#+BEGIN_SRC shell
  #@description Enable selection of calorimeter hits
  BGB.select_calorimeter_hits : boolean = true

  #@description Calorimeter tags
  BGB.select_calorimeter_hits.tags : string[2] = "__isolated" "__neighbour"
#+END_SRC
**** \gamma tracking setup
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  GT.logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC
***** Minimal probability
The following value sets the minimal TOF probability to accept a pair of
calorimeters.
#+BEGIN_SRC shell
  #@description Minimal TOF probability
  GT.minimal_probability : real = 1e-5
#+END_SRC
***** Use probability rather than gamma number
The =absolute= variable forces the gamma tracking algorithm to choose the
calorimeter assocation in the base of the best probability and not in relation
with the number of gammas.
#+BEGIN_SRC shell
  #@description Prefer probability rather than size of gamma tracked
  GT.use_absolute : boolean = false
#+END_SRC

***** Maximum size of the gamma tracked
#+BEGIN_SRC shell
  #@description Maximum size of a gamma tracked
  GT.maximal_gamma_size : integer = 0
#+END_SRC
** Topology module
:PROPERTIES:
:TANGLE: topology_modules.conf
:END:

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Module declaration
#+BEGIN_SRC shell
  [name="topology_identification" type="snemo::reconstruction::topology_module"]
#+END_SRC
**** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC

**** Data banks and services labels
#+BEGIN_SRC shell
  #@description The label of the Cut service
  Cut_label : string  = "Cuts"

  #@description The label of the 'Particle Track Data' bank
  PTD_label : string = "PTD"

  #@description The label of the 'Topology Data' bank
  TD_label : string = "TD"
#+END_SRC

**** PID driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging priority for PID driver
  PID.logging.priority : string = @variant(core:logging_priority|"warning")
#+END_SRC

***** PID mode
#+BEGIN_SRC shell
  #@description The PID mode
  PID.mode.label : boolean = true
#+END_SRC

***** Particle definitions
#+BEGIN_SRC shell
  #@description The list of particle identification definition
  PID.definitions : string[3] = "electron_definition" \
                                "gamma_definition"    \
                                "alpha_definition"
#+END_SRC

***** Particle labels
#+BEGIN_SRC shell
  #@description The label associated to 'electron' definition
  PID.electron_definition.label : string = "electron"

  #@description The label associated to 'gamma' definition
  PID.gamma_definition.label : string = "gamma"

  #@description The label associated to 'alpha' definition
  PID.alpha_definition.label : string = "alpha"
#+END_SRC

**** Measurement drivers
#+BEGIN_SRC shell
  #@description List of drivers to be used (see description below)
  drivers : string[4] = "TOFD" "VD" "AD" "ED"
#+END_SRC

**** Time-Of-Flight driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  TOFD.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC

**** Vertex driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  VD.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC

**** \theta driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  AD.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC

**** Energy driver
***** Logging priority
#+BEGIN_SRC shell
  #@description Logging flag
  ED.logging.priority : string = @variant(core:logging_priority|"error")
#+END_SRC

** Chain modules
:PROPERTIES:
:TANGLE: chain_modules.conf
:END:
This section holds most of the chain module to set "to music" the different
modules and tasks. It also contains the different paths given the selection
requirements. One important point is that module order really matters since a
module, especially =chain_module=, needs to know the declaration of all the
modules it contains.

*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Process after event header selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_event_header_cuts", cut="list_of_ids_cut", then="io_output_header_selected", else="io_output_header_non_selected")>>
#+END_SRC

*** Analysis chain
#+CAPTION: *Modules used by the analysis process.*
#+TBLNAME: analysis_chain
|-----------------------------------|
| io_output_particle_track_selected |
| remove_simulated_data             |
| remove_calibrated_data            |
| remove_tracker_clustering_data    |
| remove_tracker_trajectory_data    |
| io_output_analysed                |
|-----------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("analysis_chain", 6, analysis_chain)>>
#+END_SRC

*** Process after selecting particle track
#+BEGIN_SRC shell :noweb yes
   <<if_module("process_with_particle_track_cuts", cut="particle_track_cut", then="analysis_chain", else="io_output_particle_track_non_selected")>>
#+END_SRC

*** Particle tracking chain
#+CAPTION: *Modules used by the particle tracking process.*
#+TBLNAME: particle_tracking_chain
|----------------------------------|
| remove_particle_track_data       |
| charged_particle_tracking        |
| gamma_clustering                 |
| gamma_tracking                   |
| io_output_particle_track         |
| process_with_particle_track_cuts |
|----------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("particle_tracking_chain", 6, particle_tracking_chain)>>
#+END_SRC

*** Process after fitting selection
#+BEGIN_SRC shell :noweb yes
   <<if_module("process_with_fitting_cuts", cut="tracker_trajectory_cut", then="particle_tracking_chain", else="io_output_tracker_trajectory_non_selected")>>
#+END_SRC

*** Fitting chain
#+CAPTION: *Modules used by the fitting process.*
#+TBLNAME: fitting_chain
|--------------------------------|
| remove_tracker_trajectory_data |
| trackfit_tracker_fitting       |
| io_output_tracker_trajectory   |
| process_with_fitting_cuts      |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("fitting_chain", 4, fitting_chain)>>
#+END_SRC

*** Process after clustering selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_clustering_cuts", cut="tracker_clustering_cut", then="fitting_chain", else="io_output_tracker_clustering_non_selected")>>
#+END_SRC

*** Clustering chain
#+CAPTION: *Modules used by the clustering process.*
#+TBLNAME: clustering_chain
|--------------------------------|
| remove_tracker_clustering_data |
| cat_tracker_clustering         |
| io_output_tracker_clustering   |
| process_with_clustering_cuts   |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("clustering_chain", 4, clustering_chain)>>
#+END_SRC

*** Process after calibration selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_calibrated_cuts", cut="calibrated_cut", then="clustering_chain", else="io_output_calibrated_non_selected")>>
#+END_SRC

*** Calibration chain
#+CAPTION: *Modules used by the calibration process.*
#+TBLNAME: calibration_chain
|------------------------------|
| add_header                   |
| tracker_s2c                  |
| calorimeter_s2c              |
| io_output_calibrated         |
| process_with_calibrated_cuts |
|------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("calibration_chain", 5, calibration_chain)>>
#+END_SRC

*** Process after simulation selection
#+BEGIN_SRC shell :noweb yes
  <<if_module("process_with_simulated_cuts", cut="simulated_cut", then="calibration_chain", else="io_output_simulated_non_selected")>>
#+END_SRC

*** Simulation chain
#+CAPTION: *Modules used by the simulation process.*
#+TBLNAME: simulation_chain
|-----------------------------|
| simulation                  |
| io_output_simulated         |
| process_with_simulated_cuts |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("simulation_chain", 3, simulation_chain)>>
#+END_SRC

*** Full chain (from simulation \to calibration \to reconstruction)
#+CAPTION: *Full chain processing.*
#+TBLNAME: full_chain
|------------------|
| simulation_chain |
|------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("full_chain", 1, full_chain)>>
#+END_SRC

*** Minimum bias chain (from simulation \to calibration \to reconstruction)
#+CAPTION: *Full chain processing without selection.*
#+TBLNAME: minimum_bias_chain
|------------------------------|
| simulation                   |
| add_header                   |
| tracker_s2c                  |
| calorimeter_s2c              |
| cat_tracker_clustering       |
| trackfit_tracker_fitting     |
| io_output_tracker_trajectory |
| charged_particle_tracking    |
| gamma_clustering             |
| topology_identification      |
| io_output_analysed           |
|------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("minimum_bias_chain", 11, minimum_bias_chain)>>
#+END_SRC
*** Channel chain
**** 2\beta selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_2e_channel_selected")>>
  <<output_module("io_output_2e_channel_non_selected")>>
  <<if_module("process_2e_channel_cut", cut="2e::channel_cut", then="io_output_2e_channel_selected", else="io_output_2e_channel_non_selected")>>
#+END_SRC

**** 2\beta1\gamma selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_2e1g_channel_selected")>>
  <<output_module("io_output_2e1g_channel_non_selected")>>
  <<if_module("process_2e1g_channel_cut", cut="2e1g::channel_cut", then="io_output_2e1g_channel_selected", else="io_output_2e1g_channel_non_selected")>>
#+END_SRC

**** 2\beta2\gamma selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_2e2g_channel_selected")>>
  <<output_module("io_output_2e2g_channel_non_selected")>>
  <<if_module("process_2e2g_channel_cut", cut="2e2g::channel_cut", then="io_output_2e2g_channel_selected", else="io_output_2e2g_channel_non_selected")>>
#+END_SRC

**** 1\beta selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_1e_channel_selected")>>
  <<output_module("io_output_1e_channel_non_selected")>>
  <<if_module("process_1e_channel_cut", cut="1e::channel_cut", then="io_output_1e_channel_selected", else="io_output_1e_channel_non_selected")>>
#+END_SRC

**** 1\beta/1\gamma selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_1e1g_channel_selected")>>
  <<output_module("io_output_1e1g_channel_non_selected")>>
  <<if_module("process_1e1g_channel_cut", cut="1e1g::channel_cut", then="io_output_1e1g_channel_selected", else="io_output_1e1g_channel_non_selected")>>
#+END_SRC
**** 1\beta/2\gamma selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_1e2g_channel_selected")>>
  <<output_module("io_output_1e2g_channel_non_selected")>>
  <<if_module("process_1e2g_channel_cut", cut="1e2g::channel_cut", then="io_output_1e2g_channel_selected", else="io_output_1e2g_channel_non_selected")>>
#+END_SRC
**** 1\beta/1\alpha selection
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_1e1a_channel_selected")>>
  <<output_module("io_output_1e1a_channel_non_selected")>>
  <<if_module("process_1e1a_channel_cut", cut="1e1a::channel_cut", then="io_output_1e1a_channel_selected", else="io_output_1e1a_channel_non_selected")>>
#+END_SRC

**** Full chain
#+CAPTION: *Channel chain.*
#+TBLNAME: channel_chain
|--------------------------|
| minimum_bias_chain       |
| process_2e_channel_cut   |
| process_2e1g_channel_cut |
| process_2e2g_channel_cut |
| process_1e_channel_cut   |
| process_1e1g_channel_cut |
| process_1e2g_channel_cut |
| process_1e1a_channel_cut |
| process_report           |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("channel_chain", 9, channel_chain)>>
#+END_SRC
** Miscellaneous
:PROPERTIES:
:TANGLE: misc_modules.conf
:END:
*** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<module_preamble>>
#+END_SRC

*** Reformat data
#+CAPTION: *Reformating data.*
#+TBLNAME: reformat_data
|--------------------------------|
| remove_header                  |
| add_header                     |
| remove_mc_visu_hits            |
| remove_simulated_data          |
| remove_calibrated_data         |
| remove_tracker_clustering_data |
| remove_tracker_trajectory_data |
|--------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<chain_module("reformat_data", 7, reformat_data)>>
#+END_SRC

*** Select low energy event
#+BEGIN_SRC shell :noweb yes
  <<output_module("io_output_low_energy_selected")>>
  <<output_module("io_output_low_energy_non_selected")>>
  <<if_module("select_low_energy_event", cut="electron_with_low_energy", then="io_output_low_energy_selected", else="io_output_low_energy_non_selected")>>
#+END_SRC

* Services
:PROPERTIES:
:TANGLE: services.conf
:END:
A service generally hosts a specific resource that can be shared by many other
software components, including other services or data processing modules (see
[[https://nemo.lpc-caen.in2p3.fr/wiki/SNSW_SNailWare_FAQ#Whatisaservice][SN@ilWare FAQ]]).

#+NAME: service_preamble
#+BEGIN_SRC shell :results none :tangle no :exports none
  #@description A sample list of setups
  #@key_label   "name"
  #@meta_label  "type"
#+END_SRC

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

** Context service
#+BEGIN_SRC shell
  [name="Ctx" type="dpp::context_service"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description File from which the context is to be loaded at program start
  load.file : string as path  = "/tmp/${USER}/snemo.d/snemo_context.conf"

  #@description File to store the context at program termination
  store.file : string as path = "/tmp/${USER}/snemo.d/snemo_context_end.conf"

  #@description Flag to backup the former context load file
  backup.file : string as path = "/tmp/${USER}/snemo.d/snemo_context_bak.conf"
#+END_SRC

** Geometry service

The following code block declares the geometry service to properly load all the
geometry and material construction of the detector. This service, only declared
here, can be used by several operations like calibration, particle track
reconstruction ... but all of them will use the same geometry.

#+BEGIN_SRC shell
  [name="Geo" type="geomtools::geometry_service"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description Embedded SuperNEMO geometry manager main configuration file
  manager.configuration_file : string as path = \
      "@configuration:sngeometry_manager.conf"

  #@description Embedded SuperNEMO geometry manager must build its mapping lookup table
  manager.build_mapping : boolean = true

  #@description Embedded geometry manager's mapping lookup table does not exclude any geometry category
  manager.no_excluded_categories : boolean = true
#+END_SRC

** Cuts service

The [[https://nemo.lpc-caen.in2p3.fr/wiki/cuts][cuts]] package provides some basic classes and utilities to design, create and
apply selection cuts on arbitrary data models.

#+BEGIN_SRC shell
  [name="Cuts" type="cuts::cut_service"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The main configuration file for the embedded cut manager
  cut_manager.config : string as path =  "@configuration:cut_manager.conf"
#+END_SRC

*** Manager configuration
:PROPERTIES:
:TANGLE: cut_manager.conf
:END:

#+BEGIN_SRC shell
  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"error")

  #@description Flag to skip the preloading of pre-registered cuts
  factory.no_preload : boolean = false

  #@description A list of files that contains definition of cuts
  cuts.configuration_files : string[8] as path =       \
    "@configuration:event_header_cuts.conf"            \
    "@configuration:simulated_data_cuts.conf"          \
    "@configuration:calibrated_data_cuts.conf"         \
    "@configuration:tracker_clustering_data_cuts.conf" \
    "@configuration:tracker_trajectory_data_cuts.conf" \
    "@configuration:particle_track_data_cuts.conf"     \
    "@configuration:pid_cuts.conf"                     \
    "@configuration:topology_cuts.conf"
#+END_SRC

*** Skeleton codes                                               :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:
This section provides some options to create and declare general cuts such as
checking bank availability. Since these tasks are quite generic and depends to
few parameters, the following code blocks provides easy interface to such cuts.

**** Skeleton code for ensuring data bank presence
This skeleton code allows to check the availability of a data bank.

#+NAME: has_bank
#+HEADERS: :var cname="" :var mode="has_bank" :var bname="" :var btype="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="dpp::utils_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check availabity of '$bname'"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this utils_cut instance'
  echo 'mode : string = "'$mode'"'
  echo
  echo '#@description The name of the bank to be checked (mandatory)'
  echo $mode'.name : string = "'$bname'"'
  if [ ! -z $btype ]; then
      echo
      echo '#@description The type (as a registered user string) of the bank to be checked (optional)'
      echo $mode'.type : string = "'$btype'"'
  fi
#+END_SRC

**** Skeleton code for =multi= cuts
#+NAME: multi
#+HEADERS: :var cname="" :var mode="and" :var ncut=0 :var list="cut1 cut2 cut3" :var logging="warning"
#+BEGIN_SRC shell
  vlist=(${=list})
  echo '[name="'$cname'" type="cuts::multi_'$mode'_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Multi-'$mode' cut"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The cuts to be combined'
  echo 'cuts : string['$ncut'] = \'
  for i in $vlist
  do
      echo -n \"$i\"
      if [ $i != $vlist[-1] ]; then echo ' \';fi
  done
#+END_SRC

*** Event header cut
:PROPERTIES:
:TANGLE: event_header_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** List of event ids

#+BEGIN_SRC shell :tangle test.lis
0_50
#+END_SRC

#+BEGIN_SRC shell
  [name="list_of_ids_cut" type="snemo::cut::event_header_cut"]

  #@description Cut description
  cut.description : string = "Select event following a list of event ids"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"debug")

  #@description The label/name of the event header' bank (mandatory)
  EH_label : string = "EH"

  #@description Activate list of event ids mode
  mode.list_of_event_ids : boolean = true

  #@description Filename with event id
  list_of_event_ids.file : string as path = "@configuration:test.lis"
#+END_SRC

*** Simulated data selection
:PROPERTIES:
:TANGLE: simulated_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_simulated_data", bname="SD")>>
#+END_SRC

**** Multiple cuts
This cuts puts together all the previous declared cuts.
#+CAPTION: *Multi selection for validating simulation process.*
#+TBLNAME: simulated_cuts
|--------------------|
| has_simulated_data |
|--------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="simulated_cut", "and", 1, simulated_cuts)>>
#+END_SRC

*** Calibrated data selection
:PROPERTIES:
:TANGLE: calibrated_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_calibrated_data", bname="CD")>>
#+END_SRC

**** Check calibrated calorimeter availability
#+BEGIN_SRC shell
  [name="has_cd_calorimeter" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select calibrated calorimeter hit"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for a special boolean (flag) property
  mode.has_hit_category : boolean = true

  #@description Name of the MC hit category to be checked
  has_hit_category.category : string = "calorimeter"
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_cd_calorimeter" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_cd_calorimeter"
#+END_SRC

**** Select number of calibrated calorimeter hits
#+BEGIN_SRC shell
  [name="cd_calorimeter_cut" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of calibrated calorimeter hits"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for multiplicity of calibrated hits
  mode.range_hit_category : boolean = true

  #@description Name of the hit category to be checked
  range_hit_category.category : string = "calorimeter"

  #@description Minimal number of calibrated hits in the choosen category
  range_hit_category.min : integer = 2

  #@description Maximal number of calibrated hits in the choosen category
  range_hit_category.max : integer = 2
#+END_SRC

**** Check calibrated tracker availability
#+BEGIN_SRC shell
  [name="has_cd_tracker" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select calibrated tracker hit"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for a special boolean (flag) property
  mode.has_hit_category : boolean = true

  #@description Name of the hit category to be checked
  has_hit_category.category : string = "tracker"
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_cd_tracker" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_cd_tracker"
#+END_SRC

**** Select number of calibrated tracker hits
#+BEGIN_SRC shell
  [name="cd_tracker_cut" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of calibrated tracker hits"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for multiplicity of calibrated hits
  mode.range_hit_category : boolean = true

  #@description Name of the hit category to be checked
  range_hit_category.category : string = "tracker"

  #@description Minimal number of calibrated hits in the choosen category
  range_hit_category.min : integer = 3

  #@description Maximal number of calibrated hits in the choosen category
  #range_hit_category.max : integer = 1
#+END_SRC

**** Remove delayed calibrated tracker hits
#+BEGIN_SRC shell
  [name="has_delayed_tracker_hit" type="snemo::cut::calibrated_data_cut"]

  #@description Cut description
  cut.description : string = "Select delayed calibrated tracker hit"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  CD_label : string = "CD"

  #@description Activate the check for delayed trait bit
  mode.tracker_hit_is_delayed : boolean = true

  #@description Delayed time of the tracker hit
  tracker_hit_is_delayed.delay_time : real as time = 15 us
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_delayed_tracker_hit" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_delayed_tracker_hit"
#+END_SRC

**** Multiple cuts
This cuts puts together all the previous declared cuts.
#+CAPTION: *Multi selection for validating calibration process.*
#+TBLNAME: calibrated_cuts
|--------------------------|
| has_calibrated_data      |
| has_cd_calorimeter       |
| cd_calorimeter_cut       |
| has_cd_tracker           |
| cd_tracker_cut           |
| !has_delayed_tracker_hit |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="calibrated_cut", "and", 6, calibrated_cuts)>>
#+END_SRC

*** Tracker clustering data selection
:PROPERTIES:
:TANGLE: tracker_clustering_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_tracker_clustering_data", bname="TCD")>>
#+END_SRC

**** Check if clusters have been performed
#+BEGIN_SRC shell
  [name="has_cluster" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Check tracker cluster presence"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check of clusters presence
  mode.has_cluster : boolean = true
#+END_SRC
**** Select number of cluster
#+BEGIN_SRC shell
  [name="cluster_range_cut" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of tracker clusters"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of clusters
  mode.range_cluster : boolean = true

  #@description Minimal number of clusters
  range_cluster.min : integer = 2

  #@description Maximal number of clusters
  range_cluster.max : integer = 4
#+END_SRC

**** Select number of hit within a cluster                       :notused:
#+BEGIN_SRC shell :tangle no
  [name="tcd2_cut" type="snemo::analysis::cut::tracker_clustering_data_cut"]

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of clusters
  mode.range_tracker_hit : boolean = true

  #@description Minimal number of cells in cluster
  range_tracker_hit.min : integer = 1

  # #@description Maximal number of cells in cluster
  # range_tracker_hit.max : integer = 100000
#+END_SRC

**** "Selecting" unclustered hits
We define a serie of cut to remove event with too much unclustered hits. We
first define a cut to check is there is some unclustered hits. If yes, then we
ask tracker cluster solution to have more than 4 unclustered hits. Finally,
since we want to remove thess events, we build a =nor_cut= to keep
***** Check if unclustered hits remain
#+BEGIN_SRC shell
  [name="has_unclustered_hits" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Check unclustered hits presence"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check of unclustered hits
  mode.has_unclustered_hits : boolean = true
#+END_SRC
***** Select number of unclustered hits
#+BEGIN_SRC shell
  [name="unclustered_hits_range_cut" type="snemo::cut::tracker_clustering_data_cut"]

  #@description Cut description
  cut.description : string = "Select a given number of unclustered hits"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker clustering data' bank (mandatory)
  TCD_label : string = "TCD"

  #@description Activate the check for multiplicity of unclustered hits
  mode.range_unclustered_hits : boolean = true

  #@description Minimal number of unclustured hits
  range_unclustered_hits.min : integer = 4
#+END_SRC

***** No unclustered hits nor large number of unclustered hits
#+CAPTION: *Multi-selection for getting unclustering hits.*
#+TBLNAME: unclustered_hits_cuts
|----------------------------|
| has_unclustered_hits       |
| unclustered_hits_range_cut |
|----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="range_unclustered_hits", "and", 2, unclustered_hits_cuts)>>
#+END_SRC

Now that we have selected tracker clustering solution with large number of
unclustered hits, use the negation of this cut to keep event with low number of
unclustered hits.
#+BEGIN_SRC shell
  [name="!range_unclustered_hits" type="cuts::not_cut"]

  #@description Cut description
  cut.description : string = "Remove event with large number of unclustered hits"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description  The name of the cut to be negated
  cut : string = "range_unclustered_hits"
#+END_SRC

**** Multiple cuts
#+CAPTION: *Multi-selection for validating tracker clustering process.*
#+TBLNAME: tracker_clustering_cuts
|-----------------------------|
| has_tracker_clustering_data |
| has_cluster                 |
| cluster_range_cut           |
| !range_unclustered_hits     |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="tracker_clustering_cut", "and", 4, tracker_clustering_cuts)>>
#+END_SRC

*** Tracker trajectory data selection
:PROPERTIES:
:TANGLE: tracker_trajectory_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_tracker_trajectory_data", bname="TTD")>>
#+END_SRC

**** Check for default solution
#+BEGIN_SRC shell
  [name="has_solution_cut" type="snemo::cut::tracker_trajectory_data_cut"]

  #@description Cut description
  cut.description : string = "Select event with default solution"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker trajectory data' bank (mandatory)
  TTD_label : string = "TTD"

  #@description Activate the check for default solution
  mode.has_solution : boolean = true
#+END_SRC

**** Select only good trajectories
#+BEGIN_SRC shell
  [name="pvalue_range_cut" type="snemo::cut::tracker_trajectory_data_cut"]

  #@description Cut description
  cut.description : string = "Select event with good p-value trajectory"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'tracker trajectory data' bank (mandatory)
  TTD_label : string = "TTD"

  #@description Activate the check for good p-value trajectories
  mode.range_pvalue : boolean = true

  #@description Minimal value for p-value
  range_pvalue.min : real as fraction = 10 %
#+END_SRC

**** Multiple cuts
#+CAPTION: *Multi-selection for validating tracker trajectory process.*
#+TBLNAME: tracker_trajectory_cuts
|-----------------------------|
| has_tracker_trajectory_data |
| has_solution_cut            |
| pvalue_range_cut            |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi(cname="tracker_trajectory_cut", "and", 3, tracker_trajectory_cuts)>>
#+END_SRC

*** Particle track selection
:PROPERTIES:
:TANGLE: particle_track_data_cuts.conf
:END:

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Check bank availability
#+BEGIN_SRC shell :noweb yes
  <<has_bank("has_particle_track_data", bname="PTD")>>
#+END_SRC

**** Check if particles have been reconstructed
#+BEGIN_SRC shell
  [name="has_particle" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select reconstructed particle"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for a special boolean (flag) property
  mode.has_particles : boolean = true
#+END_SRC
**** Select number of particles
#+BEGIN_SRC shell
  [name="range_particle" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select a number of particle tracks"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'calibrated data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for multiplicity of particles trajectories
  mode.range_particles : boolean = true

  #@description Minimal number of particle track
  range_particles.min : integer = 2

  #@description Maximal number of particle track
  range_particles.max : integer = 2
#+END_SRC

**** No isolated calorimeter hits
Remove event with non associated calorimeters hits.
#+BEGIN_SRC shell
  [name="has_non_associated_calorimeter_hits" type="snemo::cut::particle_track_data_cut"]

  #@description Cut description
  cut.description : string = "Select event with non associated calorimeter hits"

  #@description Logging priority
  logging.priority : string = @variant(core:logging_priority|"warning")

  #@description The label/name of the 'particle track data' bank (mandatory)
  PTD_label : string = "PTD"

  #@description Activate the check for non associated calorimeter hits
  mode.has_non_associated_calorimeter_hits : boolean = true
#+END_SRC

#+BEGIN_SRC shell
  [name="!has_non_associated_calorimeter_hits" type="cuts::not_cut"]

  #@description The cut to be negated (mandatory)
  cut : string = "has_non_associated_calorimeter_hits"
#+END_SRC
**** Multiple cuts

#+CAPTION: *Multi-selection for validating particle tracking process.*
#+TBLNAME: particle_track_cuts
|--------------------------------------|
| has_particle_track_data              |
| has_particle                         |
| range_particle                       |
| !has_non_associated_calorimeter_hits |
|--------------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("particle_track_cut", "and", 4, particle_track_cuts)>>
#+END_SRC
*** PID selection
:PROPERTIES:
:TANGLE: pid_cuts.conf
:END:
The following cut defines what may be called a "particle" /i.e./ an electron, an
alpha in the context of SuperNEMO. Since these cuts apply on every
=particle_track=, *they must be cuts from =particle_track_cut= type*.

**** Insert preamble
#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC
**** Generic definition
***** Skeleton codes                                           :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:

****** Check electric charge
#+NAME: has_charge
#+HEADERS: :var cname="" :var type="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="snemo::cut::particle_track_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check '$type' charged track"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.has_charge : boolean = true'
  echo
  echo '#@description Request '$type' charged particle'
  echo 'has_charge.type : string = "'$type'"'
#+END_SRC

****** Check vertex
#+NAME: has_vertex
#+HEADERS: :var cname="" :var type="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="snemo::cut::particle_track_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check if track has '$type' vertex"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.has_vertex : boolean = true'
  echo
  echo '#@description Request '$type' vertex'
  echo 'has_vertex.type : string = "'$type'"'
#+END_SRC

****** Check calorimeter association
#+NAME: has_associated_calorimeter_hits
#+HEADERS: :var cname="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="snemo::cut::particle_track_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check if track has associated calorimeter hits"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.has_associated_calorimeter_hits : boolean = true'
#+END_SRC

#+NAME: has_no_associated_calorimeter_hits
#+HEADERS: :var cname="" :var logging="warning"
#+BEGIN_SRC shell
  name=${cname/no_/}
  echo '[name="'$name'" type="snemo::cut::particle_track_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check if track has associated calorimeter hits"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.has_associated_calorimeter_hits : boolean = true'
  echo
  echo '[name="'$cname'" type="cuts::not_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check if track has no associated calorimeter hits"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The name of the cut to be negated'
  echo 'cut : string = "'$name'"'
#+END_SRC
****** Check the number of associated calorimeter hits
#+NAME: range_associated_calorimeter_hits
#+HEADERS: :var cname="" :var category="" :var min=-1 :var max=-1 :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$cname'" type="snemo::cut::particle_track_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Check if track has a range of associated calorimeter hits"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.range_associated_calorimeter_hits : boolean = true'
  echo
  if [ ! -z $category ]; then
      echo '#@description The calorimeter category to be checked'
      echo 'range_associated_calorimeter_hits.category : string = "'$category'"'
      echo
  fi
  if [[ $min != -1 ]]; then
      echo '#@description The minimal number of calorimeter associated'
      echo 'range_associated_calorimeter_hits.min : integer = '$min
      echo
  fi
  if [[ $max != -1 ]]; then
      echo '#@description The maximal number of calorimeter associated'
      echo 'range_associated_calorimeter_hits.max : integer = '$max
  fi
#+END_SRC

**** $e^-$ definition
An electron is a =particle_track= having
- a negative electric charge
  #+BEGIN_SRC shell :noweb yes
    <<has_charge(cname="electron::negative_charge", type="negative")>>
    <<has_charge(cname="electron::positive_charge", type="positive")>>
    <<has_charge(cname="electron::undefined_charge", type="undefined")>>
  #+END_SRC

  #+CAPTION: *Selections used to define an electron electric charge.*
  #+TBLNAME: electron_charge
  |----------------------------|
  | electron::negative_charge  |
  | electron::positive_charge  |
  | electron::undefined_charge |
  |----------------------------|
  #+BEGIN_SRC shell :noweb yes
    <<multi("electron::electric_charge", "or", 1, electron_charge)>>
  #+END_SRC

- a vertex on the source foil
  #+BEGIN_SRC shell :noweb yes
    <<has_vertex(cname="electron::foil_vertex", type="foil")>>
  #+END_SRC
- an associated calorimeter hit
  #+BEGIN_SRC shell :noweb yes
    <<has_associated_calorimeter_hits(cname="electron::calorimeter_association")>>
  #+END_SRC

#+CAPTION: *Selections used to define an electron track.*
#+TBLNAME: electron_definition
|-----------------------------------|
| electron::electric_charge         |
| electron::calorimeter_association |
| electron::foil_vertex             |
|-----------------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("electron_definition", "and", 2, electron_definition)>>
#+END_SRC

/Addendum/

If you want to select only main wall and/or X-wall calorimeter hits for electron,
you can declare to =particle_track_cut= cut with
=range_associated_calorimeter_hits= mode enabled and then use the =multi_or= cut
from =i_cut= library. For instance,
#+BEGIN_SRC shell :noweb yes
  <<range_associated_calorimeter_hits(cname="electron::calo_association", category="calo", min=1)>>
  <<range_associated_calorimeter_hits(cname="electron::xcalo_association", category="xcalo", min=1)>>
#+END_SRC

#+CAPTION: *Selections used to select electron with =calo= or =xcalo= associated.*
#+TBLNAME: electron_calos_association
|-----------------------------|
| electron::calo_association  |
| electron::xcalo_association |
|-----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("electron::calos_association", "or", 2, electron_calos_association)>>
#+END_SRC

**** \gamma definition
A gamma is a =particle_track= having
- a neutral electric charge
  #+BEGIN_SRC shell :noweb yes
    <<has_charge(cname="gamma::neutral_charge", type="neutral")>>
  #+END_SRC
- an associated calorimeter hit
  #+BEGIN_SRC shell :noweb yes
    <<has_associated_calorimeter_hits(cname="gamma::calo_association")>>
  #+END_SRC

#+CAPTION: *Selections used to define a gamma track.*
#+TBLNAME: gamma_definition
|-------------------------|
| gamma::neutral_charge   |
| gamma::calo_association |
|-------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("gamma_definition", "and", 2, gamma_definition)>>
#+END_SRC

**** \alpha definition
An alpha is a =particle_track= having
- a undefined electric charge /i.e./ fitted by a line
  #+BEGIN_SRC shell :noweb yes
    <<has_charge(cname="alpha::undefined_charge", type="undefined")>>
  #+END_SRC
- a delayed cluster
  #+BEGIN_SRC shell
    [name="alpha::delayed_cluster" type="snemo::cut::particle_track_cut"]

    #@description Cut description
    cut.description : string = "Check delayed cluster"

    #@description Logging priority
    logging.priority : string = @variant(core:logging_priority|"error")

    #@description The running mode of this cut instance
    mode.has_delayed_cluster : boolean = true
  #+END_SRC
- a vertex on the source foil
  #+BEGIN_SRC shell :noweb yes
    <<has_vertex(cname="alpha::foil_vertex", type="foil")>>
  #+END_SRC
- no associated calorimeter hits
  #+BEGIN_SRC shell :noweb yes
    <<has_no_associated_calorimeter_hits(cname="alpha::no_calo_association")>>
  #+END_SRC

#+CAPTION: *Selections used to define an alpha track.*
#+TBLNAME: alpha_definition
|----------------------------|
| alpha::delayed_cluster     |
| alpha::undefined_charge    |
| alpha::no_calo_association |
| alpha::foil_vertex         |
|----------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("alpha_definition", "and", 3, alpha_definition)>>
#+END_SRC

*** Channel selection
:PROPERTIES:
:TANGLE: topology_cuts.conf
:END:

The following selections define some basic "standard" channel cuts such as :
- 1 electron,
- 1 electron, $n$ gammas,
- 2 internal electrons,
- 1 electron, 1 alpha particle
- 2 electron, $n$ gammas,
and maybe more in the future.

**** Insert preamble

#+BEGIN_SRC shell :noweb yes
  <<service_preamble>>
#+END_SRC

**** Skeleton codes                                             :noexport:
:PROPERTIES:
:TANGLE: no
:RESULTS: output
:END:

***** Check pattern presence
#+NAME: has_pattern
#+HEADERS: :var topo="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$topo'::has_pattern" type="snemo::cut::topology_data_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Ensure pattern presence for '$topo' topology"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description The running mode of this cut instance'
  echo 'mode.has_pattern : boolean = true'
#+END_SRC

***** Check pattern id label
#+NAME: has_pattern_id
#+HEADERS: :var topo="" :var logging="warning"
#+BEGIN_SRC shell
  echo '[name="'$topo'::has_pattern_id" type="snemo::cut::topology_data_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Select '$topo' pattern id label"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description Activate the check for pattern id label'
  echo 'mode.has_pattern_id : boolean = true'
  echo
  echo '#@description Label of the topology pattern id'
  echo 'has_pattern_id.label : string = "'$topo'"'
#+END_SRC

***** Check classification label
#+NAME: has_classification
#+HEADERS: :var topo="" :var logging="warning" :var regex=""
#+BEGIN_SRC shell
  [ -z $regex ] && regex=$topo
  echo '[name="'$topo'::has_classification" type="snemo::cut::topology_data_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Select '$topo' pattern id label"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description Activate the check for classification label'
  echo 'mode.classification : boolean = true'
  echo
  echo '#@description Label of the classification'
  echo 'classification.label : string = "'$regex'"'
#+END_SRC
***** TOF cut
#+NAME: tof_measurement_cut
#+HEADERS: :var name="" :var type="internal" :var logging="warning"
#+HEADERS: :var min="" :var max=""
#+BEGIN_SRC shell
  echo '[name="'$name'" type="snemo::cut::tof_measurement_cut"]'
  echo
  echo '#@description Cut description'
  echo 'cut.description : string = "Select event with TOF criteria"'
  echo
  echo '#@description Logging priority'
  echo 'logging.priority : string = @variant(core:logging_priority|"'$logging'")'
  echo
  echo '#@description Activate the check for '$type' probability'
  echo 'mode.has_'$type'_probability : boolean = true'
  echo
  echo '#@description Activate the check for range value of '$type' probability'
  echo 'mode.range_'$type'_probability : boolean = true'
  echo
  echo '#@description Mode 'all' for the range probability'
  echo 'range_'$type'_probability.mode : string = "all"'
  echo
  if [ ! -z $min ]; then
      echo '#@description Minimal value for '$type' probability'
      echo 'range_'$type'_probability.min : real as fraction = '$min
  fi
  if [ ! -z $max ]; then
      echo '#@description Maximal value for '$type' probability'
      echo 'range_'$type'_probability.max : real as fraction = '$max
  fi
  #+END_SRC
**** 1\beta selection

Define 1\beta events channel

- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("1e::has_topology_data", bname="TD")>>
    <<has_pattern("1e")>>
    <<has_classification("1e")>>
  #+END_SRC

#+CAPTION: *Definition of 1 electron channel.*
#+TBLNAME: 1e_channel_cut
|------------------------|
| 1e::has_topology_data  |
| 1e::has_pattern        |
| 1e::has_classification |
|------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("1e::channel_cut", "and", 3, 1e_channel_cut)>>
#+END_SRC

**** 1\beta1\gamma selection

Define 1\beta1\gamma events channel

- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("1e1g::has_topology_data", bname="TD")>>
    <<has_pattern("1e1g")>>
    <<has_classification("1e1g")>>
    # <<has_classification(topo="1e1g", regex=".*1g.*")>>
  #+END_SRC

#+CAPTION: *Definition of 1\beta1\gamma channel.*
#+TBLNAME: 1e1g_channel_cut
|--------------------------|
| 1e1g::has_topology_data  |
| 1e1g::has_pattern        |
| 1e1g::has_classification |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("1e1g::channel_cut", "and", 3, 1e1g_channel_cut)>>
#+END_SRC

**** 1\beta2\gamma selection

Define 1\beta2\gamma events channel

- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("1e2g::has_topology_data", bname="TD")>>
    <<has_pattern("1e2g")>>
    <<has_classification("1e2g")>>
  #+END_SRC

#+CAPTION: *Definition of 1\beta2\gamma channel.*
#+TBLNAME: 1e2g_channel_cut
|--------------------------|
| 1e2g::has_topology_data  |
| 1e2g::has_pattern        |
| 1e2g::has_classification |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("1e2g::channel_cut", "and", 3, 1e2g_channel_cut)>>
#+END_SRC

**** 1\beta1\alpha selection

Define 1\beta1\alpha events topology

- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("1e1a::has_topology_data", bname="TD")>>
    <<has_pattern("1e1a")>>
    <<has_classification("1e1a")>>
  #+END_SRC

#+CAPTION: *Definition of 1\beta1\alpha channel.*
#+TBLNAME: 1e1a_channel_cut
|--------------------------|
| 1e1a::has_topology_data  |
| 1e1a::has_pattern        |
| 1e1a::has_classification |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("1e1a::channel_cut", "and", 3, 1e1a_channel_cut)>>
#+END_SRC

**** 2\beta selection

Define 2\beta events channel
- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("2e::has_topology_data", bname="TD")>>
    <<has_pattern("2e")>>
    <<has_classification("2e")>>
  #+END_SRC

- select events with only 2 calibrated calorimeter hits
  #+BEGIN_SRC shell
    [name="2e::two_calibrated_calorimeters" type="snemo::cut::calibrated_data_cut"]

    #@description Cut description
    cut.description : string = "Select a given number of calibrated calorimeter hits"

    #@description Logging priority
    logging.priority : string = @variant(core:logging_priority|"warning")

    #@description The label/name of the 'calibrated data' bank (mandatory)
    CD_label : string = "CD"

    #@description Activate the check for multiplicity of calibrated hits
    mode.range_hit_category : boolean = true

    #@description Name of the hit category to be checked
    range_hit_category.category : string = "calorimeter"

    #@description Minimal number of calibrated hits in the choosen category
    range_hit_category.min : integer = 2

    #@description Maximal number of calibrated hits in the choosen category
    range_hit_category.max : integer = 2
  #+END_SRC

- select events with a given set of topology measurement which are :
  - select events with good internal probability :
    #+BEGIN_SRC shell :noweb yes
      <<tof_measurement_cut(name="2e::good_internal_probability", type="internal", min="1 %")>>
    #+END_SRC
  - select events with bad external probability :
    #+BEGIN_SRC shell :noweb yes
      <<tof_measurement_cut(name="2e::bad_external_probability", type="external", max="1 %")>>
    #+END_SRC

    Merge all of them into a =channel_cut=
    #+BEGIN_SRC shell
      [name="2e::topology_measurement" type="snemo::cut::channel_cut"]

      #@description Cut description
      cut.description : string = "Select events with good topological measurement"

      #@description Logging priority'
      logging.priority : string = @variant(core:logging_priority|"error")

      #@description Cut list
      cuts : string[2] = "int_prob" "ext_prob"

      int_prob.cut_label         : string = "2e::good_internal_probability"
      int_prob.measurement_label : string = "tof_e1_e2"
      ext_prob.cut_label         : string = "2e::bad_external_probability"
      ext_prob.measurement_label : string = "tof_e1_e2"
    #+END_SRC

The following cut combines all the previous ones to define what 2 electrons
events are
#+CAPTION: *Definition of 2 electrons channel.*
#+TBLNAME: 2e_channel_cut
|--------------------------|
| 2e::has_topology_data    |
| 2e::has_pattern          |
| 2e::has_classification   |
| 2e::topology_measurement |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("2e::channel_cut", "and", 4, 2e_channel_cut)>>
#+END_SRC

**** 2\beta1\gamma selection

Define 2\beta1\gamma events channel
- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("2e1g::has_topology_data", bname="TD")>>
    <<has_pattern("2e1g")>>
    <<has_classification("2e1g")>>
  #+END_SRC

The following cut combines all the previous ones to define what 2 electrons/1
gamma events are
#+CAPTION: *Definition of 2e1\gamma channel.*
#+TBLNAME: 2e1g_channel_cut
|--------------------------|
| 2e1g::has_topology_data  |
| 2e1g::has_pattern        |
| 2e1g::has_classification |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("2e1g::channel_cut", "and", 3, 2e1g_channel_cut)>>
#+END_SRC

**** 2\beta2\gamma selection

Define 2\beta2\gamma events channel
- generic cuts :
  #+BEGIN_SRC shell :noweb yes
    <<has_bank("2e2g::has_topology_data", bname="TD")>>
    <<has_pattern("2e2g")>>
    <<has_classification("2e2g")>>
  #+END_SRC

The following cut combines all the previous ones to define what 2 electrons/2
gamma events are
#+CAPTION: *Definition of 2e2\gamma channel.*
#+TBLNAME: 2e2g_channel_cut
|--------------------------|
| 2e2g::has_topology_data  |
| 2e2g::has_pattern        |
| 2e2g::has_classification |
|--------------------------|

#+BEGIN_SRC shell :noweb yes
  <<multi("2e2g::channel_cut", "and", 3, 2e2g_channel_cut)>>
#+END_SRC

**** Selection with regular expression
One can use regular expression to select a given classification by writing
~has_classification(topo="1g_with_others", regex=".*1g.*")~

**** Misc. cut

#+BEGIN_SRC shell
  [name="1e::maximal_energy_cut" type="snemo::cut::energy_measurement_cut"]
  mode.range_energy : boolean = true
  range_energy.max : real as energy = 400 keV

  [name="electron_with_low_energy" type="snemo::cut::channel_cut"]

  #@description Cut description
  cut.description : string = "Select events with low energy electron"

  #@description Logging priority'
  logging.priority : string = @variant(core:logging_priority|"error")

  #@description Cut list
  cuts : string[1] = "low_energy"

  low_energy.cut_label         : string = "1e::maximal_energy_cut"
  low_energy.measurement_label : string = "energy_e1"
#+END_SRC
* Running SN@ilWare processing chain

Since this configuration will run through the executable =bxdpp_processing= from
Bayeux library and not through =flsimulate+flreconstruct= binaries from Falaise
library, we should take care of loading the proper libraries. This is
automatically done with the [[DLL loader]] code where library paths to be used by
this setup are explicitely set.

Running processing pipeline is done by the =bxdpp_processing= program provided
by =dpp= library. Its call is pretty simple and only implies to have a module
manager file. Nevertheless, since we do not rely to Falaise /i.e./ we do not use
=flsimulate+flreconstruct= we must set different resource paths (geometry,
materials). This is not user-friendly at all but this is the only way so far.

For example, if you only want to do simulation, you can run the following
command

#+BEGIN_SRC shell
  bxdpp_processing                                                                             \
      --module-manager-config ./current/module_manager.conf                                    \
      --module simulation                                                                      \
      --dlls-config ./current/dlls.conf                                                        \
      --datatools::resource-path="falaise@<falaise install dir>/share/Falaise-2.0.0/resources" \
      --datatools::resource-path="configuration@<this configuration directory>"                \
      --max-records 100
#+END_SRC

An other way to run the previous command without loading the =dlls.conf= file
will be to temporarly set the =LD_LIBRARY_PATH= variable and to point it to the
=Falaise= and =Bayeux= libraries path namely
#+BEGIN_SRC shell
  LD_LIBRARY_PATH="<bayeux install dir>/bayeux/install/lib64:<falaise install dir>/falaise/install/lib64" \
  bxdpp_processing                                                                                        \
      --module-manager-config ./current/module_manager.conf                                               \
      --module simulation                                                                                 \
      --load-dll Bayeux_mctools_geant4 --load-dll Falaise                                                 \
      --datatools::resource-path="falaise@<falaise install dir>/share/Falaise-2.0.0/resources"            \
      --datatools::resource-path="configuration@<this configuration directory>"                           \
      --max-records 100
#+END_SRC

It will launch 100 simulated events using the =simulation_chain= module as
setup [[G4 simulation][in this section]].

In the same way you can run the calibration chain by doing

#+BEGIN_SRC shell
  bxdpp_processing                                                                             \
      --module-manager-config ./current/module_manager.conf                                    \
      --module calibration                                                                     \
      --dlls-config ./current/dlls.conf                                                        \
      --datatools::resource-path="falaise@<falaise install dir>/share/Falaise-2.0.0/resources" \
      --datatools::resource-path="configuration@<this configuration directory>"                \
      --input-file /tmp/$USER/io_output_simulated.brio
#+END_SRC
where file =/tmp/$USER/io_output_simulated.brio= is the one produced by the
=simulation_chain= module as defined and setup [[Simulation output][in this section]].

All the different process steps can then be run using the dedicated module such
as [[Clustering algorithms][clustering]] or [[Fitting algorithm][fitting]] Geiger cells. The most complete mode is the
=full_chain= module where all process are done from simulation \to calibration \to
track reconstruction[4].

[3] Assuming you are using a recent version of =bash=. With =c-shell= and
derivatives, =export= is replace by =setenv=. Nevertheless, this setup has never
been tested under this shells.

[4] For such processing you will need additional libraries see [[DLL loader]].
